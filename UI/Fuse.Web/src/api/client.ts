//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

export interface IFuseApiClient {

    /**
     * @return OK
     */
    accountAll(signal?: AbortSignal): Promise<Account[]>;

    /**
     * @param body (optional) 
     * @return Created
     */
    accountPOST(body: CreateAccount | undefined, signal?: AbortSignal): Promise<Account>;

    /**
     * @return OK
     */
    accountGET(id: string, signal?: AbortSignal): Promise<Account>;

    /**
     * @param body (optional) 
     * @return OK
     */
    accountPUT(id: string, body: UpdateAccount | undefined, signal?: AbortSignal): Promise<Account>;

    /**
     * @return No Content
     */
    accountDELETE(id: string, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    sqlStatus(id: string, signal?: AbortSignal): Promise<CachedAccountSqlStatusResponse>;

    /**
     * @return OK
     */
    refresh(id: string, signal?: AbortSignal): Promise<CachedAccountSqlStatusResponse>;

    /**
     * @param body (optional) 
     * @return Created
     */
    grantPOST(accountId: string, body: CreateAccountGrant | undefined, signal?: AbortSignal): Promise<Grant>;

    /**
     * @param body (optional) 
     * @return OK
     */
    grantPUT(accountId: string, grantId: string, body: UpdateAccountGrant | undefined, signal?: AbortSignal): Promise<Grant>;

    /**
     * @return No Content
     */
    grantDELETE(accountId: string, grantId: string, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    applicationAll(signal?: AbortSignal): Promise<Application[]>;

    /**
     * @param body (optional) 
     * @return Created
     */
    applicationPOST(body: CreateApplication | undefined, signal?: AbortSignal): Promise<Application>;

    /**
     * @return OK
     */
    applicationGET(id: string, signal?: AbortSignal): Promise<Application>;

    /**
     * @param body (optional) 
     * @return OK
     */
    applicationPUT(id: string, body: UpdateApplication | undefined, signal?: AbortSignal): Promise<Application>;

    /**
     * @return No Content
     */
    applicationDELETE(id: string, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return Created
     */
    instancesPOST(appId: string, body: CreateApplicationInstance | undefined, signal?: AbortSignal): Promise<ApplicationInstance>;

    /**
     * @param body (optional) 
     * @return OK
     */
    instancesPUT(appId: string, instanceId: string, body: UpdateApplicationInstance | undefined, signal?: AbortSignal): Promise<ApplicationInstance>;

    /**
     * @return No Content
     */
    instancesDELETE(appId: string, instanceId: string, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    health(appId: string, instanceId: string, signal?: AbortSignal): Promise<HealthStatusResponse>;

    /**
     * @param body (optional) 
     * @return Created
     */
    pipelinesPOST(appId: string, body: CreateApplicationPipeline | undefined, signal?: AbortSignal): Promise<ApplicationPipeline>;

    /**
     * @param body (optional) 
     * @return OK
     */
    pipelinesPUT(appId: string, pipelineId: string, body: UpdateApplicationPipeline | undefined, signal?: AbortSignal): Promise<ApplicationPipeline>;

    /**
     * @return No Content
     */
    pipelinesDELETE(appId: string, pipelineId: string, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return Created
     */
    dependenciesPOST(appId: string, instanceId: string, body: CreateApplicationDependency | undefined, signal?: AbortSignal): Promise<ApplicationInstanceDependency>;

    /**
     * @param body (optional) 
     * @return OK
     */
    dependenciesPUT(appId: string, instanceId: string, dependencyId: string, body: UpdateApplicationDependency | undefined, signal?: AbortSignal): Promise<ApplicationInstanceDependency>;

    /**
     * @return No Content
     */
    dependenciesDELETE(appId: string, instanceId: string, dependencyId: string, signal?: AbortSignal): Promise<void>;

    /**
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param action (optional) 
     * @param area (optional) 
     * @param userName (optional) 
     * @param entityId (optional) 
     * @param searchText (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    audit(startTime: Date | undefined, endTime: Date | undefined, action: AuditAction | undefined, area: AuditArea | undefined, userName: string | undefined, entityId: string | undefined, searchText: string | undefined, page: number | undefined, pageSize: number | undefined, signal?: AbortSignal): Promise<AuditLogResult>;

    /**
     * @return OK
     */
    audit2(id: string, signal?: AbortSignal): Promise<AuditLog>;

    /**
     * @return OK
     */
    actions(signal?: AbortSignal): Promise<string[]>;

    /**
     * @return OK
     */
    areas(signal?: AbortSignal): Promise<string[]>;

    /**
     * @param format (optional) 
     * @return OK
     */
    export(format: string | undefined, signal?: AbortSignal): Promise<FileResponse>;

    /**
     * @param format (optional) 
     * @return OK
     */
    template(format: string | undefined, signal?: AbortSignal): Promise<FileResponse>;

    /**
     * @param format (optional) 
     * @param file (optional) 
     * @return OK
     */
    import(format: string | undefined, file: FileParameter | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    dataStoreAll(signal?: AbortSignal): Promise<DataStore[]>;

    /**
     * @param body (optional) 
     * @return Created
     */
    dataStorePOST(body: CreateDataStore | undefined, signal?: AbortSignal): Promise<DataStore>;

    /**
     * @return OK
     */
    dataStoreGET(id: string, signal?: AbortSignal): Promise<DataStore>;

    /**
     * @param body (optional) 
     * @return OK
     */
    dataStorePUT(id: string, body: UpdateDataStore | undefined, signal?: AbortSignal): Promise<DataStore>;

    /**
     * @return No Content
     */
    dataStoreDELETE(id: string, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    environmentAll(signal?: AbortSignal): Promise<EnvironmentInfo[]>;

    /**
     * @param body (optional) 
     * @return Created
     */
    environmentPOST(body: CreateEnvironment | undefined, signal?: AbortSignal): Promise<EnvironmentInfo>;

    /**
     * @param body (optional) 
     * @return OK
     */
    environmentPUT(id: string, body: UpdateEnvironment | undefined, signal?: AbortSignal): Promise<EnvironmentInfo>;

    /**
     * @return No Content
     */
    environmentDELETE(id: string, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    applyAutomation(body: ApplyEnvironmentAutomation | undefined, signal?: AbortSignal): Promise<number>;

    /**
     * @return OK
     */
    externalResourceAll(signal?: AbortSignal): Promise<ExternalResource[]>;

    /**
     * @param body (optional) 
     * @return Created
     */
    externalResourcePOST(body: CreateExternalResource | undefined, signal?: AbortSignal): Promise<ExternalResource>;

    /**
     * @return OK
     */
    externalResourceGET(id: string, signal?: AbortSignal): Promise<ExternalResource>;

    /**
     * @param body (optional) 
     * @return OK
     */
    externalResourcePUT(id: string, body: UpdateExternalResource | undefined, signal?: AbortSignal): Promise<ExternalResource>;

    /**
     * @return No Content
     */
    externalResourceDELETE(id: string, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    identityAll(signal?: AbortSignal): Promise<Identity[]>;

    /**
     * @param body (optional) 
     * @return Created
     */
    identityPOST(body: CreateIdentity | undefined, signal?: AbortSignal): Promise<Identity>;

    /**
     * @return OK
     */
    identityGET(id: string, signal?: AbortSignal): Promise<Identity>;

    /**
     * @param body (optional) 
     * @return OK
     */
    identityPUT(id: string, body: UpdateIdentity | undefined, signal?: AbortSignal): Promise<Identity>;

    /**
     * @return No Content
     */
    identityDELETE(id: string, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return Created
     */
    assignmentPOST(identityId: string, body: CreateIdentityAssignment | undefined, signal?: AbortSignal): Promise<IdentityAssignment>;

    /**
     * @param body (optional) 
     * @return OK
     */
    assignmentPUT(identityId: string, assignmentId: string, body: UpdateIdentityAssignment | undefined, signal?: AbortSignal): Promise<IdentityAssignment>;

    /**
     * @return No Content
     */
    assignmentDELETE(identityId: string, assignmentId: string, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    kumaIntegrationAll(signal?: AbortSignal): Promise<KumaIntegrationResponse[]>;

    /**
     * @param body (optional) 
     * @return Created
     */
    kumaIntegrationPOST(body: CreateKumaIntegration | undefined, signal?: AbortSignal): Promise<KumaIntegrationResponse>;

    /**
     * @return OK
     */
    kumaIntegrationGET(id: string, signal?: AbortSignal): Promise<KumaIntegrationResponse>;

    /**
     * @param body (optional) 
     * @return OK
     */
    kumaIntegrationPUT(id: string, body: UpdateKumaIntegration | undefined, signal?: AbortSignal): Promise<KumaIntegrationResponse>;

    /**
     * @return No Content
     */
    kumaIntegrationDELETE(id: string, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    platformAll(signal?: AbortSignal): Promise<Platform[]>;

    /**
     * @param body (optional) 
     * @return Created
     */
    platformPOST(body: CreatePlatform | undefined, signal?: AbortSignal): Promise<Platform>;

    /**
     * @return OK
     */
    platformGET(id: string, signal?: AbortSignal): Promise<Platform>;

    /**
     * @param body (optional) 
     * @return OK
     */
    platformPUT(id: string, body: UpdatePlatform | undefined, signal?: AbortSignal): Promise<Platform>;

    /**
     * @return No Content
     */
    platformDELETE(id: string, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    secretProviderAll(signal?: AbortSignal): Promise<SecretProviderResponse[]>;

    /**
     * @param body (optional) 
     * @return Created
     */
    secretProviderPOST(body: CreateSecretProvider | undefined, signal?: AbortSignal): Promise<SecretProviderResponse>;

    /**
     * @return OK
     */
    secretProviderGET(id: string, signal?: AbortSignal): Promise<SecretProviderResponse>;

    /**
     * @param body (optional) 
     * @return OK
     */
    secretProviderPUT(id: string, body: UpdateSecretProvider | undefined, signal?: AbortSignal): Promise<SecretProviderResponse>;

    /**
     * @return No Content
     */
    secretProviderDELETE(id: string, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    testConnection(body: TestSecretProviderConnection | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    secretsAll(providerId: string, signal?: AbortSignal): Promise<SecretMetadataResponse[]>;

    /**
     * @param body (optional) 
     * @return Created
     */
    secrets(providerId: string, body: CreateSecret | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    rotate(providerId: string, secretName: string, body: RotateSecret | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param version (optional) 
     * @return OK
     */
    reveal(providerId: string, secretName: string, version: string | undefined, signal?: AbortSignal): Promise<SecretValueResponse>;

    /**
     * @return OK
     */
    state(signal?: AbortSignal): Promise<SecurityStateResponse>;

    /**
     * @param body (optional) 
     * @return OK
     */
    settings(body: UpdateSecuritySettings | undefined, signal?: AbortSignal): Promise<SecuritySettings>;

    /**
     * @param body (optional) 
     * @return Created
     */
    accountsPOST(body: CreateSecurityUser | undefined, signal?: AbortSignal): Promise<SecurityUserInfo>;

    /**
     * @return OK
     */
    accountsAll(signal?: AbortSignal): Promise<SecurityUserResponse[]>;

    /**
     * @param body (optional) 
     * @return OK
     */
    login(body: LoginSecurityUser | undefined, signal?: AbortSignal): Promise<LoginSession>;

    /**
     * @param body (optional) 
     * @return No Content
     */
    logout(body: LogoutSecurityUser | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    accountsPATCH(id: string, body: UpdateUser | undefined, signal?: AbortSignal): Promise<SecurityUserResponse>;

    /**
     * @return No Content
     */
    accountsDELETE(id: string, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    sqlIntegrationAll(signal?: AbortSignal): Promise<SqlIntegrationResponse[]>;

    /**
     * @param body (optional) 
     * @return Created
     */
    sqlIntegrationPOST(body: CreateSqlIntegration | undefined, signal?: AbortSignal): Promise<SqlIntegrationResponse>;

    /**
     * @return OK
     */
    sqlIntegrationGET(id: string, signal?: AbortSignal): Promise<SqlIntegrationResponse>;

    /**
     * @param body (optional) 
     * @return OK
     */
    sqlIntegrationPUT(id: string, body: UpdateSqlIntegration | undefined, signal?: AbortSignal): Promise<SqlIntegrationResponse>;

    /**
     * @return No Content
     */
    sqlIntegrationDELETE(id: string, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    permissionsOverview(id: string, signal?: AbortSignal): Promise<CachedPermissionsOverviewResponse>;

    /**
     * @return OK
     */
    refresh2(id: string, signal?: AbortSignal): Promise<CachedPermissionsOverviewResponse>;

    /**
     * @return OK
     */
    resolve(id: string, accountId: string, signal?: AbortSignal): Promise<ResolveDriftResponse>;

    /**
     * @return OK
     */
    import2(id: string, accountId: string, signal?: AbortSignal): Promise<ImportPermissionsResponse>;

    /**
     * @param body (optional) 
     * @return OK
     */
    import3(id: string, body: ImportOrphanPrincipalRequest | undefined, signal?: AbortSignal): Promise<ImportOrphanPrincipalResponse>;

    /**
     * @param body (optional) 
     * @return OK
     */
    create(id: string, accountId: string, body: CreateSqlAccountRequest | undefined, signal?: AbortSignal): Promise<CreateSqlAccountResponse>;

    /**
     * @param body (optional) 
     * @return OK
     */
    bulkResolve(id: string, body: BulkResolveRequest | undefined, signal?: AbortSignal): Promise<BulkResolveResponse>;

    /**
     * @param body (optional) 
     * @return OK
     */
    testConnection2(body: TestSqlConnection | undefined, signal?: AbortSignal): Promise<SqlConnectionTestResult>;

    /**
     * @return OK
     */
    databases(id: string, signal?: AbortSignal): Promise<SqlDatabasesResponse>;

    /**
     * @return OK
     */
    tagAll(signal?: AbortSignal): Promise<Tag[]>;

    /**
     * @param body (optional) 
     * @return Created
     */
    tagPOST(body: CreateTag | undefined, signal?: AbortSignal): Promise<Tag>;

    /**
     * @return OK
     */
    tagGET(id: string, signal?: AbortSignal): Promise<Tag>;

    /**
     * @param body (optional) 
     * @return OK
     */
    tagPUT(id: string, body: UpdateTag | undefined, signal?: AbortSignal): Promise<Tag>;

    /**
     * @return No Content
     */
    tagDELETE(id: string, signal?: AbortSignal): Promise<void>;
}

export class FuseApiClient implements IFuseApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    accountAll(signal?: AbortSignal): Promise<Account[]> {
        let url_ = this.baseUrl + "/api/Account";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAccountAll(_response);
        });
    }

    protected processAccountAll(response: Response): Promise<Account[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Account.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Account[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    accountPOST(body: CreateAccount | undefined, signal?: AbortSignal): Promise<Account> {
        let url_ = this.baseUrl + "/api/Account";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAccountPOST(_response);
        });
    }

    protected processAccountPOST(response: Response): Promise<Account> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Account.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Account>(null as any);
    }

    /**
     * @return OK
     */
    accountGET(id: string, signal?: AbortSignal): Promise<Account> {
        let url_ = this.baseUrl + "/api/Account/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAccountGET(_response);
        });
    }

    protected processAccountGET(response: Response): Promise<Account> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Account.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Account>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    accountPUT(id: string, body: UpdateAccount | undefined, signal?: AbortSignal): Promise<Account> {
        let url_ = this.baseUrl + "/api/Account/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAccountPUT(_response);
        });
    }

    protected processAccountPUT(response: Response): Promise<Account> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Account.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Account>(null as any);
    }

    /**
     * @return No Content
     */
    accountDELETE(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Account/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAccountDELETE(_response);
        });
    }

    protected processAccountDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    sqlStatus(id: string, signal?: AbortSignal): Promise<CachedAccountSqlStatusResponse> {
        let url_ = this.baseUrl + "/api/Account/{id}/sql-status";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSqlStatus(_response);
        });
    }

    protected processSqlStatus(response: Response): Promise<CachedAccountSqlStatusResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CachedAccountSqlStatusResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CachedAccountSqlStatusResponse>(null as any);
    }

    /**
     * @return OK
     */
    refresh(id: string, signal?: AbortSignal): Promise<CachedAccountSqlStatusResponse> {
        let url_ = this.baseUrl + "/api/Account/{id}/sql-status/refresh";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRefresh(_response);
        });
    }

    protected processRefresh(response: Response): Promise<CachedAccountSqlStatusResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CachedAccountSqlStatusResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CachedAccountSqlStatusResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    grantPOST(accountId: string, body: CreateAccountGrant | undefined, signal?: AbortSignal): Promise<Grant> {
        let url_ = this.baseUrl + "/api/Account/{accountId}/grant";
        if (accountId === undefined || accountId === null)
            throw new globalThis.Error("The parameter 'accountId' must be defined.");
        url_ = url_.replace("{accountId}", encodeURIComponent("" + accountId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGrantPOST(_response);
        });
    }

    protected processGrantPOST(response: Response): Promise<Grant> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Grant.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Grant>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    grantPUT(accountId: string, grantId: string, body: UpdateAccountGrant | undefined, signal?: AbortSignal): Promise<Grant> {
        let url_ = this.baseUrl + "/api/Account/{accountId}/grant/{grantId}";
        if (accountId === undefined || accountId === null)
            throw new globalThis.Error("The parameter 'accountId' must be defined.");
        url_ = url_.replace("{accountId}", encodeURIComponent("" + accountId));
        if (grantId === undefined || grantId === null)
            throw new globalThis.Error("The parameter 'grantId' must be defined.");
        url_ = url_.replace("{grantId}", encodeURIComponent("" + grantId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGrantPUT(_response);
        });
    }

    protected processGrantPUT(response: Response): Promise<Grant> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Grant.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Grant>(null as any);
    }

    /**
     * @return No Content
     */
    grantDELETE(accountId: string, grantId: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Account/{accountId}/grant/{grantId}";
        if (accountId === undefined || accountId === null)
            throw new globalThis.Error("The parameter 'accountId' must be defined.");
        url_ = url_.replace("{accountId}", encodeURIComponent("" + accountId));
        if (grantId === undefined || grantId === null)
            throw new globalThis.Error("The parameter 'grantId' must be defined.");
        url_ = url_.replace("{grantId}", encodeURIComponent("" + grantId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGrantDELETE(_response);
        });
    }

    protected processGrantDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    applicationAll(signal?: AbortSignal): Promise<Application[]> {
        let url_ = this.baseUrl + "/api/Application";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApplicationAll(_response);
        });
    }

    protected processApplicationAll(response: Response): Promise<Application[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Application.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Application[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    applicationPOST(body: CreateApplication | undefined, signal?: AbortSignal): Promise<Application> {
        let url_ = this.baseUrl + "/api/Application";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApplicationPOST(_response);
        });
    }

    protected processApplicationPOST(response: Response): Promise<Application> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Application.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Application>(null as any);
    }

    /**
     * @return OK
     */
    applicationGET(id: string, signal?: AbortSignal): Promise<Application> {
        let url_ = this.baseUrl + "/api/Application/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApplicationGET(_response);
        });
    }

    protected processApplicationGET(response: Response): Promise<Application> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Application.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Application>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    applicationPUT(id: string, body: UpdateApplication | undefined, signal?: AbortSignal): Promise<Application> {
        let url_ = this.baseUrl + "/api/Application/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApplicationPUT(_response);
        });
    }

    protected processApplicationPUT(response: Response): Promise<Application> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Application.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Application>(null as any);
    }

    /**
     * @return No Content
     */
    applicationDELETE(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Application/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApplicationDELETE(_response);
        });
    }

    protected processApplicationDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    instancesPOST(appId: string, body: CreateApplicationInstance | undefined, signal?: AbortSignal): Promise<ApplicationInstance> {
        let url_ = this.baseUrl + "/api/Application/{appId}/instances";
        if (appId === undefined || appId === null)
            throw new globalThis.Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInstancesPOST(_response);
        });
    }

    protected processInstancesPOST(response: Response): Promise<ApplicationInstance> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ApplicationInstance.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApplicationInstance>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    instancesPUT(appId: string, instanceId: string, body: UpdateApplicationInstance | undefined, signal?: AbortSignal): Promise<ApplicationInstance> {
        let url_ = this.baseUrl + "/api/Application/{appId}/instances/{instanceId}";
        if (appId === undefined || appId === null)
            throw new globalThis.Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (instanceId === undefined || instanceId === null)
            throw new globalThis.Error("The parameter 'instanceId' must be defined.");
        url_ = url_.replace("{instanceId}", encodeURIComponent("" + instanceId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInstancesPUT(_response);
        });
    }

    protected processInstancesPUT(response: Response): Promise<ApplicationInstance> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationInstance.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApplicationInstance>(null as any);
    }

    /**
     * @return No Content
     */
    instancesDELETE(appId: string, instanceId: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Application/{appId}/instances/{instanceId}";
        if (appId === undefined || appId === null)
            throw new globalThis.Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (instanceId === undefined || instanceId === null)
            throw new globalThis.Error("The parameter 'instanceId' must be defined.");
        url_ = url_.replace("{instanceId}", encodeURIComponent("" + instanceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInstancesDELETE(_response);
        });
    }

    protected processInstancesDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    health(appId: string, instanceId: string, signal?: AbortSignal): Promise<HealthStatusResponse> {
        let url_ = this.baseUrl + "/api/Application/{appId}/instances/{instanceId}/health";
        if (appId === undefined || appId === null)
            throw new globalThis.Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (instanceId === undefined || instanceId === null)
            throw new globalThis.Error("The parameter 'instanceId' must be defined.");
        url_ = url_.replace("{instanceId}", encodeURIComponent("" + instanceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHealth(_response);
        });
    }

    protected processHealth(response: Response): Promise<HealthStatusResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HealthStatusResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<HealthStatusResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    pipelinesPOST(appId: string, body: CreateApplicationPipeline | undefined, signal?: AbortSignal): Promise<ApplicationPipeline> {
        let url_ = this.baseUrl + "/api/Application/{appId}/pipelines";
        if (appId === undefined || appId === null)
            throw new globalThis.Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPipelinesPOST(_response);
        });
    }

    protected processPipelinesPOST(response: Response): Promise<ApplicationPipeline> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ApplicationPipeline.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApplicationPipeline>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    pipelinesPUT(appId: string, pipelineId: string, body: UpdateApplicationPipeline | undefined, signal?: AbortSignal): Promise<ApplicationPipeline> {
        let url_ = this.baseUrl + "/api/Application/{appId}/pipelines/{pipelineId}";
        if (appId === undefined || appId === null)
            throw new globalThis.Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (pipelineId === undefined || pipelineId === null)
            throw new globalThis.Error("The parameter 'pipelineId' must be defined.");
        url_ = url_.replace("{pipelineId}", encodeURIComponent("" + pipelineId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPipelinesPUT(_response);
        });
    }

    protected processPipelinesPUT(response: Response): Promise<ApplicationPipeline> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationPipeline.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApplicationPipeline>(null as any);
    }

    /**
     * @return No Content
     */
    pipelinesDELETE(appId: string, pipelineId: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Application/{appId}/pipelines/{pipelineId}";
        if (appId === undefined || appId === null)
            throw new globalThis.Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (pipelineId === undefined || pipelineId === null)
            throw new globalThis.Error("The parameter 'pipelineId' must be defined.");
        url_ = url_.replace("{pipelineId}", encodeURIComponent("" + pipelineId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPipelinesDELETE(_response);
        });
    }

    protected processPipelinesDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    dependenciesPOST(appId: string, instanceId: string, body: CreateApplicationDependency | undefined, signal?: AbortSignal): Promise<ApplicationInstanceDependency> {
        let url_ = this.baseUrl + "/api/Application/{appId}/instances/{instanceId}/dependencies";
        if (appId === undefined || appId === null)
            throw new globalThis.Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (instanceId === undefined || instanceId === null)
            throw new globalThis.Error("The parameter 'instanceId' must be defined.");
        url_ = url_.replace("{instanceId}", encodeURIComponent("" + instanceId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDependenciesPOST(_response);
        });
    }

    protected processDependenciesPOST(response: Response): Promise<ApplicationInstanceDependency> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ApplicationInstanceDependency.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApplicationInstanceDependency>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    dependenciesPUT(appId: string, instanceId: string, dependencyId: string, body: UpdateApplicationDependency | undefined, signal?: AbortSignal): Promise<ApplicationInstanceDependency> {
        let url_ = this.baseUrl + "/api/Application/{appId}/instances/{instanceId}/dependencies/{dependencyId}";
        if (appId === undefined || appId === null)
            throw new globalThis.Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (instanceId === undefined || instanceId === null)
            throw new globalThis.Error("The parameter 'instanceId' must be defined.");
        url_ = url_.replace("{instanceId}", encodeURIComponent("" + instanceId));
        if (dependencyId === undefined || dependencyId === null)
            throw new globalThis.Error("The parameter 'dependencyId' must be defined.");
        url_ = url_.replace("{dependencyId}", encodeURIComponent("" + dependencyId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDependenciesPUT(_response);
        });
    }

    protected processDependenciesPUT(response: Response): Promise<ApplicationInstanceDependency> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationInstanceDependency.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApplicationInstanceDependency>(null as any);
    }

    /**
     * @return No Content
     */
    dependenciesDELETE(appId: string, instanceId: string, dependencyId: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Application/{appId}/instances/{instanceId}/dependencies/{dependencyId}";
        if (appId === undefined || appId === null)
            throw new globalThis.Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (instanceId === undefined || instanceId === null)
            throw new globalThis.Error("The parameter 'instanceId' must be defined.");
        url_ = url_.replace("{instanceId}", encodeURIComponent("" + instanceId));
        if (dependencyId === undefined || dependencyId === null)
            throw new globalThis.Error("The parameter 'dependencyId' must be defined.");
        url_ = url_.replace("{dependencyId}", encodeURIComponent("" + dependencyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDependenciesDELETE(_response);
        });
    }

    protected processDependenciesDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param action (optional) 
     * @param area (optional) 
     * @param userName (optional) 
     * @param entityId (optional) 
     * @param searchText (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    audit(startTime: Date | undefined, endTime: Date | undefined, action: AuditAction | undefined, area: AuditArea | undefined, userName: string | undefined, entityId: string | undefined, searchText: string | undefined, page: number | undefined, pageSize: number | undefined, signal?: AbortSignal): Promise<AuditLogResult> {
        let url_ = this.baseUrl + "/api/Audit?";
        if (startTime === null)
            throw new globalThis.Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "startTime=" + encodeURIComponent(startTime ? "" + startTime.toISOString() : "") + "&";
        if (endTime === null)
            throw new globalThis.Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "endTime=" + encodeURIComponent(endTime ? "" + endTime.toISOString() : "") + "&";
        if (action === null)
            throw new globalThis.Error("The parameter 'action' cannot be null.");
        else if (action !== undefined)
            url_ += "action=" + encodeURIComponent("" + action) + "&";
        if (area === null)
            throw new globalThis.Error("The parameter 'area' cannot be null.");
        else if (area !== undefined)
            url_ += "area=" + encodeURIComponent("" + area) + "&";
        if (userName === null)
            throw new globalThis.Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        if (entityId === null)
            throw new globalThis.Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "entityId=" + encodeURIComponent("" + entityId) + "&";
        if (searchText === null)
            throw new globalThis.Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAudit(_response);
        });
    }

    protected processAudit(response: Response): Promise<AuditLogResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuditLogResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuditLogResult>(null as any);
    }

    /**
     * @return OK
     */
    audit2(id: string, signal?: AbortSignal): Promise<AuditLog> {
        let url_ = this.baseUrl + "/api/Audit/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAudit2(_response);
        });
    }

    protected processAudit2(response: Response): Promise<AuditLog> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuditLog.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuditLog>(null as any);
    }

    /**
     * @return OK
     */
    actions(signal?: AbortSignal): Promise<string[]> {
        let url_ = this.baseUrl + "/api/Audit/actions";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processActions(_response);
        });
    }

    protected processActions(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(null as any);
    }

    /**
     * @return OK
     */
    areas(signal?: AbortSignal): Promise<string[]> {
        let url_ = this.baseUrl + "/api/Audit/areas";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAreas(_response);
        });
    }

    protected processAreas(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(null as any);
    }

    /**
     * @param format (optional) 
     * @return OK
     */
    export(format: string | undefined, signal?: AbortSignal): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Config/export?";
        if (format === null)
            throw new globalThis.Error("The parameter 'format' cannot be null.");
        else if (format !== undefined)
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExport(_response);
        });
    }

    protected processExport(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * @param format (optional) 
     * @return OK
     */
    template(format: string | undefined, signal?: AbortSignal): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Config/template?";
        if (format === null)
            throw new globalThis.Error("The parameter 'format' cannot be null.");
        else if (format !== undefined)
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTemplate(_response);
        });
    }

    protected processTemplate(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * @param format (optional) 
     * @param file (optional) 
     * @return OK
     */
    import(format: string | undefined, file: FileParameter | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Config/import?";
        if (format === null)
            throw new globalThis.Error("The parameter 'format' cannot be null.");
        else if (format !== undefined)
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new globalThis.Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processImport(_response);
        });
    }

    protected processImport(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    dataStoreAll(signal?: AbortSignal): Promise<DataStore[]> {
        let url_ = this.baseUrl + "/api/DataStore";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDataStoreAll(_response);
        });
    }

    protected processDataStoreAll(response: Response): Promise<DataStore[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DataStore.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DataStore[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    dataStorePOST(body: CreateDataStore | undefined, signal?: AbortSignal): Promise<DataStore> {
        let url_ = this.baseUrl + "/api/DataStore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDataStorePOST(_response);
        });
    }

    protected processDataStorePOST(response: Response): Promise<DataStore> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = DataStore.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DataStore>(null as any);
    }

    /**
     * @return OK
     */
    dataStoreGET(id: string, signal?: AbortSignal): Promise<DataStore> {
        let url_ = this.baseUrl + "/api/DataStore/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDataStoreGET(_response);
        });
    }

    protected processDataStoreGET(response: Response): Promise<DataStore> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataStore.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DataStore>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    dataStorePUT(id: string, body: UpdateDataStore | undefined, signal?: AbortSignal): Promise<DataStore> {
        let url_ = this.baseUrl + "/api/DataStore/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDataStorePUT(_response);
        });
    }

    protected processDataStorePUT(response: Response): Promise<DataStore> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataStore.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DataStore>(null as any);
    }

    /**
     * @return No Content
     */
    dataStoreDELETE(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/DataStore/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDataStoreDELETE(_response);
        });
    }

    protected processDataStoreDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    environmentAll(signal?: AbortSignal): Promise<EnvironmentInfo[]> {
        let url_ = this.baseUrl + "/api/Environment";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEnvironmentAll(_response);
        });
    }

    protected processEnvironmentAll(response: Response): Promise<EnvironmentInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnvironmentInfo.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EnvironmentInfo[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    environmentPOST(body: CreateEnvironment | undefined, signal?: AbortSignal): Promise<EnvironmentInfo> {
        let url_ = this.baseUrl + "/api/Environment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEnvironmentPOST(_response);
        });
    }

    protected processEnvironmentPOST(response: Response): Promise<EnvironmentInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = EnvironmentInfo.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EnvironmentInfo>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    environmentPUT(id: string, body: UpdateEnvironment | undefined, signal?: AbortSignal): Promise<EnvironmentInfo> {
        let url_ = this.baseUrl + "/api/Environment/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEnvironmentPUT(_response);
        });
    }

    protected processEnvironmentPUT(response: Response): Promise<EnvironmentInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EnvironmentInfo.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EnvironmentInfo>(null as any);
    }

    /**
     * @return No Content
     */
    environmentDELETE(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Environment/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEnvironmentDELETE(_response);
        });
    }

    protected processEnvironmentDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    applyAutomation(body: ApplyEnvironmentAutomation | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Environment/apply-automation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApplyAutomation(_response);
        });
    }

    protected processApplyAutomation(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @return OK
     */
    externalResourceAll(signal?: AbortSignal): Promise<ExternalResource[]> {
        let url_ = this.baseUrl + "/api/ExternalResource";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExternalResourceAll(_response);
        });
    }

    protected processExternalResourceAll(response: Response): Promise<ExternalResource[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExternalResource.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExternalResource[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    externalResourcePOST(body: CreateExternalResource | undefined, signal?: AbortSignal): Promise<ExternalResource> {
        let url_ = this.baseUrl + "/api/ExternalResource";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExternalResourcePOST(_response);
        });
    }

    protected processExternalResourcePOST(response: Response): Promise<ExternalResource> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ExternalResource.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExternalResource>(null as any);
    }

    /**
     * @return OK
     */
    externalResourceGET(id: string, signal?: AbortSignal): Promise<ExternalResource> {
        let url_ = this.baseUrl + "/api/ExternalResource/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExternalResourceGET(_response);
        });
    }

    protected processExternalResourceGET(response: Response): Promise<ExternalResource> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalResource.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExternalResource>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    externalResourcePUT(id: string, body: UpdateExternalResource | undefined, signal?: AbortSignal): Promise<ExternalResource> {
        let url_ = this.baseUrl + "/api/ExternalResource/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExternalResourcePUT(_response);
        });
    }

    protected processExternalResourcePUT(response: Response): Promise<ExternalResource> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalResource.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExternalResource>(null as any);
    }

    /**
     * @return No Content
     */
    externalResourceDELETE(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/ExternalResource/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExternalResourceDELETE(_response);
        });
    }

    protected processExternalResourceDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    identityAll(signal?: AbortSignal): Promise<Identity[]> {
        let url_ = this.baseUrl + "/api/Identity";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIdentityAll(_response);
        });
    }

    protected processIdentityAll(response: Response): Promise<Identity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Identity.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Identity[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    identityPOST(body: CreateIdentity | undefined, signal?: AbortSignal): Promise<Identity> {
        let url_ = this.baseUrl + "/api/Identity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIdentityPOST(_response);
        });
    }

    protected processIdentityPOST(response: Response): Promise<Identity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Identity.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Identity>(null as any);
    }

    /**
     * @return OK
     */
    identityGET(id: string, signal?: AbortSignal): Promise<Identity> {
        let url_ = this.baseUrl + "/api/Identity/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIdentityGET(_response);
        });
    }

    protected processIdentityGET(response: Response): Promise<Identity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Identity.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Identity>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    identityPUT(id: string, body: UpdateIdentity | undefined, signal?: AbortSignal): Promise<Identity> {
        let url_ = this.baseUrl + "/api/Identity/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIdentityPUT(_response);
        });
    }

    protected processIdentityPUT(response: Response): Promise<Identity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Identity.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Identity>(null as any);
    }

    /**
     * @return No Content
     */
    identityDELETE(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Identity/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIdentityDELETE(_response);
        });
    }

    protected processIdentityDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    assignmentPOST(identityId: string, body: CreateIdentityAssignment | undefined, signal?: AbortSignal): Promise<IdentityAssignment> {
        let url_ = this.baseUrl + "/api/Identity/{identityId}/assignment";
        if (identityId === undefined || identityId === null)
            throw new globalThis.Error("The parameter 'identityId' must be defined.");
        url_ = url_.replace("{identityId}", encodeURIComponent("" + identityId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAssignmentPOST(_response);
        });
    }

    protected processAssignmentPOST(response: Response): Promise<IdentityAssignment> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = IdentityAssignment.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentityAssignment>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    assignmentPUT(identityId: string, assignmentId: string, body: UpdateIdentityAssignment | undefined, signal?: AbortSignal): Promise<IdentityAssignment> {
        let url_ = this.baseUrl + "/api/Identity/{identityId}/assignment/{assignmentId}";
        if (identityId === undefined || identityId === null)
            throw new globalThis.Error("The parameter 'identityId' must be defined.");
        url_ = url_.replace("{identityId}", encodeURIComponent("" + identityId));
        if (assignmentId === undefined || assignmentId === null)
            throw new globalThis.Error("The parameter 'assignmentId' must be defined.");
        url_ = url_.replace("{assignmentId}", encodeURIComponent("" + assignmentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAssignmentPUT(_response);
        });
    }

    protected processAssignmentPUT(response: Response): Promise<IdentityAssignment> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdentityAssignment.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentityAssignment>(null as any);
    }

    /**
     * @return No Content
     */
    assignmentDELETE(identityId: string, assignmentId: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Identity/{identityId}/assignment/{assignmentId}";
        if (identityId === undefined || identityId === null)
            throw new globalThis.Error("The parameter 'identityId' must be defined.");
        url_ = url_.replace("{identityId}", encodeURIComponent("" + identityId));
        if (assignmentId === undefined || assignmentId === null)
            throw new globalThis.Error("The parameter 'assignmentId' must be defined.");
        url_ = url_.replace("{assignmentId}", encodeURIComponent("" + assignmentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAssignmentDELETE(_response);
        });
    }

    protected processAssignmentDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    kumaIntegrationAll(signal?: AbortSignal): Promise<KumaIntegrationResponse[]> {
        let url_ = this.baseUrl + "/api/KumaIntegration";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processKumaIntegrationAll(_response);
        });
    }

    protected processKumaIntegrationAll(response: Response): Promise<KumaIntegrationResponse[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(KumaIntegrationResponse.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<KumaIntegrationResponse[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    kumaIntegrationPOST(body: CreateKumaIntegration | undefined, signal?: AbortSignal): Promise<KumaIntegrationResponse> {
        let url_ = this.baseUrl + "/api/KumaIntegration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processKumaIntegrationPOST(_response);
        });
    }

    protected processKumaIntegrationPOST(response: Response): Promise<KumaIntegrationResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = KumaIntegrationResponse.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<KumaIntegrationResponse>(null as any);
    }

    /**
     * @return OK
     */
    kumaIntegrationGET(id: string, signal?: AbortSignal): Promise<KumaIntegrationResponse> {
        let url_ = this.baseUrl + "/api/KumaIntegration/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processKumaIntegrationGET(_response);
        });
    }

    protected processKumaIntegrationGET(response: Response): Promise<KumaIntegrationResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KumaIntegrationResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<KumaIntegrationResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    kumaIntegrationPUT(id: string, body: UpdateKumaIntegration | undefined, signal?: AbortSignal): Promise<KumaIntegrationResponse> {
        let url_ = this.baseUrl + "/api/KumaIntegration/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processKumaIntegrationPUT(_response);
        });
    }

    protected processKumaIntegrationPUT(response: Response): Promise<KumaIntegrationResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KumaIntegrationResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<KumaIntegrationResponse>(null as any);
    }

    /**
     * @return No Content
     */
    kumaIntegrationDELETE(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/KumaIntegration/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processKumaIntegrationDELETE(_response);
        });
    }

    protected processKumaIntegrationDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    platformAll(signal?: AbortSignal): Promise<Platform[]> {
        let url_ = this.baseUrl + "/api/Platform";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPlatformAll(_response);
        });
    }

    protected processPlatformAll(response: Response): Promise<Platform[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Platform.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Platform[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    platformPOST(body: CreatePlatform | undefined, signal?: AbortSignal): Promise<Platform> {
        let url_ = this.baseUrl + "/api/Platform";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPlatformPOST(_response);
        });
    }

    protected processPlatformPOST(response: Response): Promise<Platform> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Platform.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Platform>(null as any);
    }

    /**
     * @return OK
     */
    platformGET(id: string, signal?: AbortSignal): Promise<Platform> {
        let url_ = this.baseUrl + "/api/Platform/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPlatformGET(_response);
        });
    }

    protected processPlatformGET(response: Response): Promise<Platform> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Platform.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Platform>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    platformPUT(id: string, body: UpdatePlatform | undefined, signal?: AbortSignal): Promise<Platform> {
        let url_ = this.baseUrl + "/api/Platform/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPlatformPUT(_response);
        });
    }

    protected processPlatformPUT(response: Response): Promise<Platform> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Platform.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Platform>(null as any);
    }

    /**
     * @return No Content
     */
    platformDELETE(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Platform/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPlatformDELETE(_response);
        });
    }

    protected processPlatformDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    secretProviderAll(signal?: AbortSignal): Promise<SecretProviderResponse[]> {
        let url_ = this.baseUrl + "/api/SecretProvider";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSecretProviderAll(_response);
        });
    }

    protected processSecretProviderAll(response: Response): Promise<SecretProviderResponse[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SecretProviderResponse.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SecretProviderResponse[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    secretProviderPOST(body: CreateSecretProvider | undefined, signal?: AbortSignal): Promise<SecretProviderResponse> {
        let url_ = this.baseUrl + "/api/SecretProvider";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSecretProviderPOST(_response);
        });
    }

    protected processSecretProviderPOST(response: Response): Promise<SecretProviderResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = SecretProviderResponse.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SecretProviderResponse>(null as any);
    }

    /**
     * @return OK
     */
    secretProviderGET(id: string, signal?: AbortSignal): Promise<SecretProviderResponse> {
        let url_ = this.baseUrl + "/api/SecretProvider/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSecretProviderGET(_response);
        });
    }

    protected processSecretProviderGET(response: Response): Promise<SecretProviderResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecretProviderResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SecretProviderResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    secretProviderPUT(id: string, body: UpdateSecretProvider | undefined, signal?: AbortSignal): Promise<SecretProviderResponse> {
        let url_ = this.baseUrl + "/api/SecretProvider/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSecretProviderPUT(_response);
        });
    }

    protected processSecretProviderPUT(response: Response): Promise<SecretProviderResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecretProviderResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SecretProviderResponse>(null as any);
    }

    /**
     * @return No Content
     */
    secretProviderDELETE(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/SecretProvider/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSecretProviderDELETE(_response);
        });
    }

    protected processSecretProviderDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    testConnection(body: TestSecretProviderConnection | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/SecretProvider/test-connection";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTestConnection(_response);
        });
    }

    protected processTestConnection(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    secretsAll(providerId: string, signal?: AbortSignal): Promise<SecretMetadataResponse[]> {
        let url_ = this.baseUrl + "/api/SecretProvider/{providerId}/secrets";
        if (providerId === undefined || providerId === null)
            throw new globalThis.Error("The parameter 'providerId' must be defined.");
        url_ = url_.replace("{providerId}", encodeURIComponent("" + providerId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSecretsAll(_response);
        });
    }

    protected processSecretsAll(response: Response): Promise<SecretMetadataResponse[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SecretMetadataResponse.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SecretMetadataResponse[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    secrets(providerId: string, body: CreateSecret | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/SecretProvider/{providerId}/secrets";
        if (providerId === undefined || providerId === null)
            throw new globalThis.Error("The parameter 'providerId' must be defined.");
        url_ = url_.replace("{providerId}", encodeURIComponent("" + providerId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSecrets(_response);
        });
    }

    protected processSecrets(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    rotate(providerId: string, secretName: string, body: RotateSecret | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/SecretProvider/{providerId}/secrets/{secretName}/rotate";
        if (providerId === undefined || providerId === null)
            throw new globalThis.Error("The parameter 'providerId' must be defined.");
        url_ = url_.replace("{providerId}", encodeURIComponent("" + providerId));
        if (secretName === undefined || secretName === null)
            throw new globalThis.Error("The parameter 'secretName' must be defined.");
        url_ = url_.replace("{secretName}", encodeURIComponent("" + secretName));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRotate(_response);
        });
    }

    protected processRotate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param version (optional) 
     * @return OK
     */
    reveal(providerId: string, secretName: string, version: string | undefined, signal?: AbortSignal): Promise<SecretValueResponse> {
        let url_ = this.baseUrl + "/api/SecretProvider/{providerId}/secrets/{secretName}/reveal?";
        if (providerId === undefined || providerId === null)
            throw new globalThis.Error("The parameter 'providerId' must be defined.");
        url_ = url_.replace("{providerId}", encodeURIComponent("" + providerId));
        if (secretName === undefined || secretName === null)
            throw new globalThis.Error("The parameter 'secretName' must be defined.");
        url_ = url_.replace("{secretName}", encodeURIComponent("" + secretName));
        if (version === null)
            throw new globalThis.Error("The parameter 'version' cannot be null.");
        else if (version !== undefined)
            url_ += "version=" + encodeURIComponent("" + version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReveal(_response);
        });
    }

    protected processReveal(response: Response): Promise<SecretValueResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecretValueResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SecretValueResponse>(null as any);
    }

    /**
     * @return OK
     */
    state(signal?: AbortSignal): Promise<SecurityStateResponse> {
        let url_ = this.baseUrl + "/api/Security/state";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processState(_response);
        });
    }

    protected processState(response: Response): Promise<SecurityStateResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityStateResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SecurityStateResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    settings(body: UpdateSecuritySettings | undefined, signal?: AbortSignal): Promise<SecuritySettings> {
        let url_ = this.baseUrl + "/api/Security/settings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSettings(_response);
        });
    }

    protected processSettings(response: Response): Promise<SecuritySettings> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecuritySettings.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SecuritySettings>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    accountsPOST(body: CreateSecurityUser | undefined, signal?: AbortSignal): Promise<SecurityUserInfo> {
        let url_ = this.baseUrl + "/api/Security/accounts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAccountsPOST(_response);
        });
    }

    protected processAccountsPOST(response: Response): Promise<SecurityUserInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = SecurityUserInfo.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SecurityUserInfo>(null as any);
    }

    /**
     * @return OK
     */
    accountsAll(signal?: AbortSignal): Promise<SecurityUserResponse[]> {
        let url_ = this.baseUrl + "/api/Security/accounts";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAccountsAll(_response);
        });
    }

    protected processAccountsAll(response: Response): Promise<SecurityUserResponse[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SecurityUserResponse.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SecurityUserResponse[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    login(body: LoginSecurityUser | undefined, signal?: AbortSignal): Promise<LoginSession> {
        let url_ = this.baseUrl + "/api/Security/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<LoginSession> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginSession.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LoginSession>(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    logout(body: LogoutSecurityUser | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Security/logout";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogout(_response);
        });
    }

    protected processLogout(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    accountsPATCH(id: string, body: UpdateUser | undefined, signal?: AbortSignal): Promise<SecurityUserResponse> {
        let url_ = this.baseUrl + "/api/Security/accounts/{Id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAccountsPATCH(_response);
        });
    }

    protected processAccountsPATCH(response: Response): Promise<SecurityUserResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityUserResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SecurityUserResponse>(null as any);
    }

    /**
     * @return No Content
     */
    accountsDELETE(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Security/accounts/{Id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAccountsDELETE(_response);
        });
    }

    protected processAccountsDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    sqlIntegrationAll(signal?: AbortSignal): Promise<SqlIntegrationResponse[]> {
        let url_ = this.baseUrl + "/api/SqlIntegration";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSqlIntegrationAll(_response);
        });
    }

    protected processSqlIntegrationAll(response: Response): Promise<SqlIntegrationResponse[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SqlIntegrationResponse.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SqlIntegrationResponse[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    sqlIntegrationPOST(body: CreateSqlIntegration | undefined, signal?: AbortSignal): Promise<SqlIntegrationResponse> {
        let url_ = this.baseUrl + "/api/SqlIntegration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSqlIntegrationPOST(_response);
        });
    }

    protected processSqlIntegrationPOST(response: Response): Promise<SqlIntegrationResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = SqlIntegrationResponse.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SqlIntegrationResponse>(null as any);
    }

    /**
     * @return OK
     */
    sqlIntegrationGET(id: string, signal?: AbortSignal): Promise<SqlIntegrationResponse> {
        let url_ = this.baseUrl + "/api/SqlIntegration/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSqlIntegrationGET(_response);
        });
    }

    protected processSqlIntegrationGET(response: Response): Promise<SqlIntegrationResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SqlIntegrationResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SqlIntegrationResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    sqlIntegrationPUT(id: string, body: UpdateSqlIntegration | undefined, signal?: AbortSignal): Promise<SqlIntegrationResponse> {
        let url_ = this.baseUrl + "/api/SqlIntegration/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSqlIntegrationPUT(_response);
        });
    }

    protected processSqlIntegrationPUT(response: Response): Promise<SqlIntegrationResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SqlIntegrationResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SqlIntegrationResponse>(null as any);
    }

    /**
     * @return No Content
     */
    sqlIntegrationDELETE(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/SqlIntegration/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSqlIntegrationDELETE(_response);
        });
    }

    protected processSqlIntegrationDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    permissionsOverview(id: string, signal?: AbortSignal): Promise<CachedPermissionsOverviewResponse> {
        let url_ = this.baseUrl + "/api/SqlIntegration/{id}/permissions-overview";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPermissionsOverview(_response);
        });
    }

    protected processPermissionsOverview(response: Response): Promise<CachedPermissionsOverviewResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CachedPermissionsOverviewResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CachedPermissionsOverviewResponse>(null as any);
    }

    /**
     * @return OK
     */
    refresh2(id: string, signal?: AbortSignal): Promise<CachedPermissionsOverviewResponse> {
        let url_ = this.baseUrl + "/api/SqlIntegration/{id}/permissions-overview/refresh";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRefresh2(_response);
        });
    }

    protected processRefresh2(response: Response): Promise<CachedPermissionsOverviewResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CachedPermissionsOverviewResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CachedPermissionsOverviewResponse>(null as any);
    }

    /**
     * @return OK
     */
    resolve(id: string, accountId: string, signal?: AbortSignal): Promise<ResolveDriftResponse> {
        let url_ = this.baseUrl + "/api/SqlIntegration/{id}/accounts/{accountId}/resolve";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (accountId === undefined || accountId === null)
            throw new globalThis.Error("The parameter 'accountId' must be defined.");
        url_ = url_.replace("{accountId}", encodeURIComponent("" + accountId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResolve(_response);
        });
    }

    protected processResolve(response: Response): Promise<ResolveDriftResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResolveDriftResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResolveDriftResponse>(null as any);
    }

    /**
     * @return OK
     */
    import2(id: string, accountId: string, signal?: AbortSignal): Promise<ImportPermissionsResponse> {
        let url_ = this.baseUrl + "/api/SqlIntegration/{id}/accounts/{accountId}/import";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (accountId === undefined || accountId === null)
            throw new globalThis.Error("The parameter 'accountId' must be defined.");
        url_ = url_.replace("{accountId}", encodeURIComponent("" + accountId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processImport2(_response);
        });
    }

    protected processImport2(response: Response): Promise<ImportPermissionsResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImportPermissionsResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ImportPermissionsResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    import3(id: string, body: ImportOrphanPrincipalRequest | undefined, signal?: AbortSignal): Promise<ImportOrphanPrincipalResponse> {
        let url_ = this.baseUrl + "/api/SqlIntegration/{id}/orphan-principals/import";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processImport3(_response);
        });
    }

    protected processImport3(response: Response): Promise<ImportOrphanPrincipalResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImportOrphanPrincipalResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ImportOrphanPrincipalResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(id: string, accountId: string, body: CreateSqlAccountRequest | undefined, signal?: AbortSignal): Promise<CreateSqlAccountResponse> {
        let url_ = this.baseUrl + "/api/SqlIntegration/{id}/accounts/{accountId}/create";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (accountId === undefined || accountId === null)
            throw new globalThis.Error("The parameter 'accountId' must be defined.");
        url_ = url_.replace("{accountId}", encodeURIComponent("" + accountId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<CreateSqlAccountResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateSqlAccountResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CreateSqlAccountResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    bulkResolve(id: string, body: BulkResolveRequest | undefined, signal?: AbortSignal): Promise<BulkResolveResponse> {
        let url_ = this.baseUrl + "/api/SqlIntegration/{id}/bulk-resolve";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBulkResolve(_response);
        });
    }

    protected processBulkResolve(response: Response): Promise<BulkResolveResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkResolveResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BulkResolveResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    testConnection2(body: TestSqlConnection | undefined, signal?: AbortSignal): Promise<SqlConnectionTestResult> {
        let url_ = this.baseUrl + "/api/SqlIntegration/test-connection";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTestConnection2(_response);
        });
    }

    protected processTestConnection2(response: Response): Promise<SqlConnectionTestResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SqlConnectionTestResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SqlConnectionTestResult>(null as any);
    }

    /**
     * @return OK
     */
    databases(id: string, signal?: AbortSignal): Promise<SqlDatabasesResponse> {
        let url_ = this.baseUrl + "/api/SqlIntegration/{id}/databases";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDatabases(_response);
        });
    }

    protected processDatabases(response: Response): Promise<SqlDatabasesResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SqlDatabasesResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SqlDatabasesResponse>(null as any);
    }

    /**
     * @return OK
     */
    tagAll(signal?: AbortSignal): Promise<Tag[]> {
        let url_ = this.baseUrl + "/api/Tag";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTagAll(_response);
        });
    }

    protected processTagAll(response: Response): Promise<Tag[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Tag.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Tag[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    tagPOST(body: CreateTag | undefined, signal?: AbortSignal): Promise<Tag> {
        let url_ = this.baseUrl + "/api/Tag";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTagPOST(_response);
        });
    }

    protected processTagPOST(response: Response): Promise<Tag> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Tag.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Tag>(null as any);
    }

    /**
     * @return OK
     */
    tagGET(id: string, signal?: AbortSignal): Promise<Tag> {
        let url_ = this.baseUrl + "/api/Tag/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTagGET(_response);
        });
    }

    protected processTagGET(response: Response): Promise<Tag> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Tag.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Tag>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    tagPUT(id: string, body: UpdateTag | undefined, signal?: AbortSignal): Promise<Tag> {
        let url_ = this.baseUrl + "/api/Tag/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTagPUT(_response);
        });
    }

    protected processTagPUT(response: Response): Promise<Tag> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Tag.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Tag>(null as any);
    }

    /**
     * @return No Content
     */
    tagDELETE(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Tag/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTagDELETE(_response);
        });
    }

    protected processTagDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class Account implements IAccount {
    id?: string;
    targetId?: string;
    targetKind?: TargetKind;
    authKind?: AuthKind;
    secretBinding?: SecretBinding;
    userName?: string | undefined;
    parameters?: { [key: string]: string; } | undefined;
    grants?: Grant[] | undefined;
    tagIds?: string[] | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    readonly secretRef?: string | undefined;

    constructor(data?: IAccount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.targetId = _data["TargetId"];
            this.targetKind = _data["TargetKind"];
            this.authKind = _data["AuthKind"];
            this.secretBinding = _data["SecretBinding"] ? SecretBinding.fromJS(_data["SecretBinding"]) : undefined as any;
            this.userName = _data["UserName"];
            if (_data["Parameters"]) {
                this.parameters = {} as any;
                for (let key in _data["Parameters"]) {
                    if (_data["Parameters"].hasOwnProperty(key))
                        (this.parameters as any)![key] = _data["Parameters"][key];
                }
            }
            if (Array.isArray(_data["Grants"])) {
                this.grants = [] as any;
                for (let item of _data["Grants"])
                    this.grants!.push(Grant.fromJS(item));
            }
            if (Array.isArray(_data["TagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["TagIds"])
                    this.tagIds!.push(item);
            }
            this.createdAt = _data["CreatedAt"] ? new Date(_data["CreatedAt"].toString()) : undefined as any;
            this.updatedAt = _data["UpdatedAt"] ? new Date(_data["UpdatedAt"].toString()) : undefined as any;
            (this as any).secretRef = _data["SecretRef"];
        }
    }

    static fromJS(data: any): Account {
        data = typeof data === 'object' ? data : {};
        let result = new Account();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["TargetId"] = this.targetId;
        data["TargetKind"] = this.targetKind;
        data["AuthKind"] = this.authKind;
        data["SecretBinding"] = this.secretBinding ? this.secretBinding.toJSON() : undefined as any;
        data["UserName"] = this.userName;
        if (this.parameters) {
            data["Parameters"] = {};
            for (let key in this.parameters) {
                if (this.parameters.hasOwnProperty(key))
                    (data["Parameters"] as any)[key] = (this.parameters as any)[key];
            }
        }
        if (Array.isArray(this.grants)) {
            data["Grants"] = [];
            for (let item of this.grants)
                data["Grants"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.tagIds)) {
            data["TagIds"] = [];
            for (let item of this.tagIds)
                data["TagIds"].push(item);
        }
        data["CreatedAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        data["SecretRef"] = this.secretRef;
        return data;
    }
}

export interface IAccount {
    id?: string;
    targetId?: string;
    targetKind?: TargetKind;
    authKind?: AuthKind;
    secretBinding?: SecretBinding;
    userName?: string | undefined;
    parameters?: { [key: string]: string; } | undefined;
    grants?: Grant[] | undefined;
    tagIds?: string[] | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    secretRef?: string | undefined;
}

export class AccountSqlStatusResponse implements IAccountSqlStatusResponse {
    accountId?: string;
    sqlIntegrationId?: string | undefined;
    sqlIntegrationName?: string | undefined;
    status?: SyncStatus;
    statusSummary?: string | undefined;
    permissionComparisons?: SqlPermissionComparison[] | undefined;
    errorMessage?: string | undefined;

    constructor(data?: IAccountSqlStatusResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountId = _data["AccountId"];
            this.sqlIntegrationId = _data["SqlIntegrationId"];
            this.sqlIntegrationName = _data["SqlIntegrationName"];
            this.status = _data["Status"];
            this.statusSummary = _data["StatusSummary"];
            if (Array.isArray(_data["PermissionComparisons"])) {
                this.permissionComparisons = [] as any;
                for (let item of _data["PermissionComparisons"])
                    this.permissionComparisons!.push(SqlPermissionComparison.fromJS(item));
            }
            this.errorMessage = _data["ErrorMessage"];
        }
    }

    static fromJS(data: any): AccountSqlStatusResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AccountSqlStatusResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AccountId"] = this.accountId;
        data["SqlIntegrationId"] = this.sqlIntegrationId;
        data["SqlIntegrationName"] = this.sqlIntegrationName;
        data["Status"] = this.status;
        data["StatusSummary"] = this.statusSummary;
        if (Array.isArray(this.permissionComparisons)) {
            data["PermissionComparisons"] = [];
            for (let item of this.permissionComparisons)
                data["PermissionComparisons"].push(item ? item.toJSON() : undefined as any);
        }
        data["ErrorMessage"] = this.errorMessage;
        return data;
    }
}

export interface IAccountSqlStatusResponse {
    accountId?: string;
    sqlIntegrationId?: string | undefined;
    sqlIntegrationName?: string | undefined;
    status?: SyncStatus;
    statusSummary?: string | undefined;
    permissionComparisons?: SqlPermissionComparison[] | undefined;
    errorMessage?: string | undefined;
}

export class Application implements IApplication {
    id?: string;
    name?: string | undefined;
    version?: string | undefined;
    description?: string | undefined;
    owner?: string | undefined;
    notes?: string | undefined;
    framework?: string | undefined;
    repositoryUri?: string | undefined;
    icon?: string | undefined;
    tagIds?: string[] | undefined;
    instances?: ApplicationInstance[] | undefined;
    pipelines?: ApplicationPipeline[] | undefined;
    createdAt?: Date;
    updatedAt?: Date;

    constructor(data?: IApplication) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.version = _data["Version"];
            this.description = _data["Description"];
            this.owner = _data["Owner"];
            this.notes = _data["Notes"];
            this.framework = _data["Framework"];
            this.repositoryUri = _data["RepositoryUri"];
            this.icon = _data["Icon"];
            if (Array.isArray(_data["TagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["TagIds"])
                    this.tagIds!.push(item);
            }
            if (Array.isArray(_data["Instances"])) {
                this.instances = [] as any;
                for (let item of _data["Instances"])
                    this.instances!.push(ApplicationInstance.fromJS(item));
            }
            if (Array.isArray(_data["Pipelines"])) {
                this.pipelines = [] as any;
                for (let item of _data["Pipelines"])
                    this.pipelines!.push(ApplicationPipeline.fromJS(item));
            }
            this.createdAt = _data["CreatedAt"] ? new Date(_data["CreatedAt"].toString()) : undefined as any;
            this.updatedAt = _data["UpdatedAt"] ? new Date(_data["UpdatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): Application {
        data = typeof data === 'object' ? data : {};
        let result = new Application();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Version"] = this.version;
        data["Description"] = this.description;
        data["Owner"] = this.owner;
        data["Notes"] = this.notes;
        data["Framework"] = this.framework;
        data["RepositoryUri"] = this.repositoryUri;
        data["Icon"] = this.icon;
        if (Array.isArray(this.tagIds)) {
            data["TagIds"] = [];
            for (let item of this.tagIds)
                data["TagIds"].push(item);
        }
        if (Array.isArray(this.instances)) {
            data["Instances"] = [];
            for (let item of this.instances)
                data["Instances"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.pipelines)) {
            data["Pipelines"] = [];
            for (let item of this.pipelines)
                data["Pipelines"].push(item ? item.toJSON() : undefined as any);
        }
        data["CreatedAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IApplication {
    id?: string;
    name?: string | undefined;
    version?: string | undefined;
    description?: string | undefined;
    owner?: string | undefined;
    notes?: string | undefined;
    framework?: string | undefined;
    repositoryUri?: string | undefined;
    icon?: string | undefined;
    tagIds?: string[] | undefined;
    instances?: ApplicationInstance[] | undefined;
    pipelines?: ApplicationPipeline[] | undefined;
    createdAt?: Date;
    updatedAt?: Date;
}

export class ApplicationInstance implements IApplicationInstance {
    id?: string;
    environmentId?: string;
    platformId?: string | undefined;
    baseUri?: string | undefined;
    healthUri?: string | undefined;
    openApiUri?: string | undefined;
    version?: string | undefined;
    dependencies?: ApplicationInstanceDependency[] | undefined;
    tagIds?: string[] | undefined;
    createdAt?: Date;
    updatedAt?: Date;

    constructor(data?: IApplicationInstance) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.environmentId = _data["EnvironmentId"];
            this.platformId = _data["PlatformId"];
            this.baseUri = _data["BaseUri"];
            this.healthUri = _data["HealthUri"];
            this.openApiUri = _data["OpenApiUri"];
            this.version = _data["Version"];
            if (Array.isArray(_data["Dependencies"])) {
                this.dependencies = [] as any;
                for (let item of _data["Dependencies"])
                    this.dependencies!.push(ApplicationInstanceDependency.fromJS(item));
            }
            if (Array.isArray(_data["TagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["TagIds"])
                    this.tagIds!.push(item);
            }
            this.createdAt = _data["CreatedAt"] ? new Date(_data["CreatedAt"].toString()) : undefined as any;
            this.updatedAt = _data["UpdatedAt"] ? new Date(_data["UpdatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): ApplicationInstance {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInstance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["EnvironmentId"] = this.environmentId;
        data["PlatformId"] = this.platformId;
        data["BaseUri"] = this.baseUri;
        data["HealthUri"] = this.healthUri;
        data["OpenApiUri"] = this.openApiUri;
        data["Version"] = this.version;
        if (Array.isArray(this.dependencies)) {
            data["Dependencies"] = [];
            for (let item of this.dependencies)
                data["Dependencies"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.tagIds)) {
            data["TagIds"] = [];
            for (let item of this.tagIds)
                data["TagIds"].push(item);
        }
        data["CreatedAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IApplicationInstance {
    id?: string;
    environmentId?: string;
    platformId?: string | undefined;
    baseUri?: string | undefined;
    healthUri?: string | undefined;
    openApiUri?: string | undefined;
    version?: string | undefined;
    dependencies?: ApplicationInstanceDependency[] | undefined;
    tagIds?: string[] | undefined;
    createdAt?: Date;
    updatedAt?: Date;
}

export class ApplicationInstanceDependency implements IApplicationInstanceDependency {
    id?: string;
    targetId?: string;
    targetKind?: TargetKind;
    port?: number | undefined;
    authKind?: DependencyAuthKind;
    accountId?: string | undefined;
    identityId?: string | undefined;

    constructor(data?: IApplicationInstanceDependency) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.targetId = _data["TargetId"];
            this.targetKind = _data["TargetKind"];
            this.port = _data["Port"];
            this.authKind = _data["AuthKind"];
            this.accountId = _data["AccountId"];
            this.identityId = _data["IdentityId"];
        }
    }

    static fromJS(data: any): ApplicationInstanceDependency {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInstanceDependency();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["TargetId"] = this.targetId;
        data["TargetKind"] = this.targetKind;
        data["Port"] = this.port;
        data["AuthKind"] = this.authKind;
        data["AccountId"] = this.accountId;
        data["IdentityId"] = this.identityId;
        return data;
    }
}

export interface IApplicationInstanceDependency {
    id?: string;
    targetId?: string;
    targetKind?: TargetKind;
    port?: number | undefined;
    authKind?: DependencyAuthKind;
    accountId?: string | undefined;
    identityId?: string | undefined;
}

export class ApplicationPipeline implements IApplicationPipeline {
    id?: string;
    name?: string | undefined;
    pipelineUri?: string | undefined;

    constructor(data?: IApplicationPipeline) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.pipelineUri = _data["PipelineUri"];
        }
    }

    static fromJS(data: any): ApplicationPipeline {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationPipeline();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["PipelineUri"] = this.pipelineUri;
        return data;
    }
}

export interface IApplicationPipeline {
    id?: string;
    name?: string | undefined;
    pipelineUri?: string | undefined;
}

export class ApplyEnvironmentAutomation implements IApplyEnvironmentAutomation {
    environmentId?: string | undefined;
    applicationId?: string | undefined;

    constructor(data?: IApplyEnvironmentAutomation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.environmentId = _data["EnvironmentId"];
            this.applicationId = _data["ApplicationId"];
        }
    }

    static fromJS(data: any): ApplyEnvironmentAutomation {
        data = typeof data === 'object' ? data : {};
        let result = new ApplyEnvironmentAutomation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["EnvironmentId"] = this.environmentId;
        data["ApplicationId"] = this.applicationId;
        return data;
    }
}

export interface IApplyEnvironmentAutomation {
    environmentId?: string | undefined;
    applicationId?: string | undefined;
}

export enum AuditAction {
    ApplicationCreated = "ApplicationCreated",
    ApplicationUpdated = "ApplicationUpdated",
    ApplicationDeleted = "ApplicationDeleted",
    ApplicationInstanceCreated = "ApplicationInstanceCreated",
    ApplicationInstanceUpdated = "ApplicationInstanceUpdated",
    ApplicationInstanceDeleted = "ApplicationInstanceDeleted",
    AccountCreated = "AccountCreated",
    AccountUpdated = "AccountUpdated",
    AccountDeleted = "AccountDeleted",
    AccountGrantCreated = "AccountGrantCreated",
    AccountGrantUpdated = "AccountGrantUpdated",
    AccountGrantDeleted = "AccountGrantDeleted",
    DataStoreCreated = "DataStoreCreated",
    DataStoreUpdated = "DataStoreUpdated",
    DataStoreDeleted = "DataStoreDeleted",
    EnvironmentCreated = "EnvironmentCreated",
    EnvironmentUpdated = "EnvironmentUpdated",
    EnvironmentDeleted = "EnvironmentDeleted",
    ExternalResourceCreated = "ExternalResourceCreated",
    ExternalResourceUpdated = "ExternalResourceUpdated",
    ExternalResourceDeleted = "ExternalResourceDeleted",
    PlatformCreated = "PlatformCreated",
    PlatformUpdated = "PlatformUpdated",
    PlatformDeleted = "PlatformDeleted",
    TagCreated = "TagCreated",
    TagUpdated = "TagUpdated",
    TagDeleted = "TagDeleted",
    SecurityUserCreated = "SecurityUserCreated",
    SecurityUserUpdated = "SecurityUserUpdated",
    SecurityUserDeleted = "SecurityUserDeleted",
    SecurityUserLogin = "SecurityUserLogin",
    SecurityUserLogout = "SecurityUserLogout",
    SecuritySettingsUpdated = "SecuritySettingsUpdated",
    KumaIntegrationCreated = "KumaIntegrationCreated",
    KumaIntegrationUpdated = "KumaIntegrationUpdated",
    KumaIntegrationDeleted = "KumaIntegrationDeleted",
    SecretProviderCreated = "SecretProviderCreated",
    SecretProviderUpdated = "SecretProviderUpdated",
    SecretProviderDeleted = "SecretProviderDeleted",
    SecretProviderTested = "SecretProviderTested",
    SecretCreated = "SecretCreated",
    SecretRotated = "SecretRotated",
    SecretRevealed = "SecretRevealed",
    ConfigImported = "ConfigImported",
    ConfigExported = "ConfigExported",
    SqlIntegrationDriftResolved = "SqlIntegrationDriftResolved",
    SqlAccountCreated = "SqlAccountCreated",
    SqlIntegrationBulkResolved = "SqlIntegrationBulkResolved",
    SqlPermissionsImported = "SqlPermissionsImported",
    SqlOrphanPrincipalImported = "SqlOrphanPrincipalImported",
}

export enum AuditArea {
    Application = "Application",
    Account = "Account",
    DataStore = "DataStore",
    Environment = "Environment",
    ExternalResource = "ExternalResource",
    Platform = "Platform",
    Tag = "Tag",
    Security = "Security",
    KumaIntegration = "KumaIntegration",
    SecretProvider = "SecretProvider",
    Secret = "Secret",
    Config = "Config",
    SqlIntegration = "SqlIntegration",
}

export class AuditLog implements IAuditLog {
    id?: string;
    timestamp?: Date;
    action?: AuditAction;
    area?: AuditArea;
    userName?: string | undefined;
    userId?: string | undefined;
    entityId?: string | undefined;
    changeDetails?: string | undefined;

    constructor(data?: IAuditLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.timestamp = _data["Timestamp"] ? new Date(_data["Timestamp"].toString()) : undefined as any;
            this.action = _data["Action"];
            this.area = _data["Area"];
            this.userName = _data["UserName"];
            this.userId = _data["UserId"];
            this.entityId = _data["EntityId"];
            this.changeDetails = _data["ChangeDetails"];
        }
    }

    static fromJS(data: any): AuditLog {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Timestamp"] = this.timestamp ? this.timestamp.toISOString() : undefined as any;
        data["Action"] = this.action;
        data["Area"] = this.area;
        data["UserName"] = this.userName;
        data["UserId"] = this.userId;
        data["EntityId"] = this.entityId;
        data["ChangeDetails"] = this.changeDetails;
        return data;
    }
}

export interface IAuditLog {
    id?: string;
    timestamp?: Date;
    action?: AuditAction;
    area?: AuditArea;
    userName?: string | undefined;
    userId?: string | undefined;
    entityId?: string | undefined;
    changeDetails?: string | undefined;
}

export class AuditLogResult implements IAuditLogResult {
    logs?: AuditLog[] | undefined;
    totalCount?: number;
    page?: number;
    pageSize?: number;
    readonly totalPages?: number;

    constructor(data?: IAuditLogResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["Logs"])) {
                this.logs = [] as any;
                for (let item of _data["Logs"])
                    this.logs!.push(AuditLog.fromJS(item));
            }
            this.totalCount = _data["TotalCount"];
            this.page = _data["Page"];
            this.pageSize = _data["PageSize"];
            (this as any).totalPages = _data["TotalPages"];
        }
    }

    static fromJS(data: any): AuditLogResult {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.logs)) {
            data["Logs"] = [];
            for (let item of this.logs)
                data["Logs"].push(item ? item.toJSON() : undefined as any);
        }
        data["TotalCount"] = this.totalCount;
        data["Page"] = this.page;
        data["PageSize"] = this.pageSize;
        data["TotalPages"] = this.totalPages;
        return data;
    }
}

export interface IAuditLogResult {
    logs?: AuditLog[] | undefined;
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
}

export enum AuthKind {
    None = "None",
    UserPassword = "UserPassword",
    ApiKey = "ApiKey",
    BearerToken = "BearerToken",
    OAuthClient = "OAuthClient",
    ManagedIdentity = "ManagedIdentity",
    Certificate = "Certificate",
    Other = "Other",
}

export class AzureKeyVaultBinding implements IAzureKeyVaultBinding {
    providerId?: string;
    secretName?: string | undefined;
    version?: string | undefined;

    constructor(data?: IAzureKeyVaultBinding) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.providerId = _data["ProviderId"];
            this.secretName = _data["SecretName"];
            this.version = _data["Version"];
        }
    }

    static fromJS(data: any): AzureKeyVaultBinding {
        data = typeof data === 'object' ? data : {};
        let result = new AzureKeyVaultBinding();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ProviderId"] = this.providerId;
        data["SecretName"] = this.secretName;
        data["Version"] = this.version;
        return data;
    }
}

export interface IAzureKeyVaultBinding {
    providerId?: string;
    secretName?: string | undefined;
    version?: string | undefined;
}

export enum BulkPasswordSource {
    SecretProvider = "SecretProvider",
}

export class BulkResolveAccountResult implements IBulkResolveAccountResult {
    accountId?: string;
    accountName?: string | undefined;
    principalName?: string | undefined;
    operationType?: string | undefined;
    success?: boolean;
    errorMessage?: string | undefined;
    updatedStatus?: SqlAccountPermissionsStatus;

    constructor(data?: IBulkResolveAccountResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountId = _data["AccountId"];
            this.accountName = _data["AccountName"];
            this.principalName = _data["PrincipalName"];
            this.operationType = _data["OperationType"];
            this.success = _data["Success"];
            this.errorMessage = _data["ErrorMessage"];
            this.updatedStatus = _data["UpdatedStatus"] ? SqlAccountPermissionsStatus.fromJS(_data["UpdatedStatus"]) : undefined as any;
        }
    }

    static fromJS(data: any): BulkResolveAccountResult {
        data = typeof data === 'object' ? data : {};
        let result = new BulkResolveAccountResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AccountId"] = this.accountId;
        data["AccountName"] = this.accountName;
        data["PrincipalName"] = this.principalName;
        data["OperationType"] = this.operationType;
        data["Success"] = this.success;
        data["ErrorMessage"] = this.errorMessage;
        data["UpdatedStatus"] = this.updatedStatus ? this.updatedStatus.toJSON() : undefined as any;
        return data;
    }
}

export interface IBulkResolveAccountResult {
    accountId?: string;
    accountName?: string | undefined;
    principalName?: string | undefined;
    operationType?: string | undefined;
    success?: boolean;
    errorMessage?: string | undefined;
    updatedStatus?: SqlAccountPermissionsStatus;
}

export class BulkResolveRequest implements IBulkResolveRequest {
    passwordSource?: BulkPasswordSource;

    constructor(data?: IBulkResolveRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.passwordSource = _data["PasswordSource"];
        }
    }

    static fromJS(data: any): BulkResolveRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BulkResolveRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PasswordSource"] = this.passwordSource;
        return data;
    }
}

export interface IBulkResolveRequest {
    passwordSource?: BulkPasswordSource;
}

export class BulkResolveResponse implements IBulkResolveResponse {
    integrationId?: string;
    success?: boolean;
    summary?: BulkResolveSummary;
    results?: BulkResolveAccountResult[] | undefined;
    errorMessage?: string | undefined;

    constructor(data?: IBulkResolveResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.integrationId = _data["IntegrationId"];
            this.success = _data["Success"];
            this.summary = _data["Summary"] ? BulkResolveSummary.fromJS(_data["Summary"]) : undefined as any;
            if (Array.isArray(_data["Results"])) {
                this.results = [] as any;
                for (let item of _data["Results"])
                    this.results!.push(BulkResolveAccountResult.fromJS(item));
            }
            this.errorMessage = _data["ErrorMessage"];
        }
    }

    static fromJS(data: any): BulkResolveResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BulkResolveResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["IntegrationId"] = this.integrationId;
        data["Success"] = this.success;
        data["Summary"] = this.summary ? this.summary.toJSON() : undefined as any;
        if (Array.isArray(this.results)) {
            data["Results"] = [];
            for (let item of this.results)
                data["Results"].push(item ? item.toJSON() : undefined as any);
        }
        data["ErrorMessage"] = this.errorMessage;
        return data;
    }
}

export interface IBulkResolveResponse {
    integrationId?: string;
    success?: boolean;
    summary?: BulkResolveSummary;
    results?: BulkResolveAccountResult[] | undefined;
    errorMessage?: string | undefined;
}

export class BulkResolveSummary implements IBulkResolveSummary {
    totalProcessed?: number;
    accountsCreated?: number;
    driftsResolved?: number;
    skipped?: number;
    failed?: number;

    constructor(data?: IBulkResolveSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalProcessed = _data["TotalProcessed"];
            this.accountsCreated = _data["AccountsCreated"];
            this.driftsResolved = _data["DriftsResolved"];
            this.skipped = _data["Skipped"];
            this.failed = _data["Failed"];
        }
    }

    static fromJS(data: any): BulkResolveSummary {
        data = typeof data === 'object' ? data : {};
        let result = new BulkResolveSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TotalProcessed"] = this.totalProcessed;
        data["AccountsCreated"] = this.accountsCreated;
        data["DriftsResolved"] = this.driftsResolved;
        data["Skipped"] = this.skipped;
        data["Failed"] = this.failed;
        return data;
    }
}

export interface IBulkResolveSummary {
    totalProcessed?: number;
    accountsCreated?: number;
    driftsResolved?: number;
    skipped?: number;
    failed?: number;
}

export class CachedAccountSqlStatusResponse implements ICachedAccountSqlStatusResponse {
    status?: AccountSqlStatusResponse;
    cachedAt?: Date | undefined;
    isCached?: boolean;

    constructor(data?: ICachedAccountSqlStatusResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["Status"] ? AccountSqlStatusResponse.fromJS(_data["Status"]) : undefined as any;
            this.cachedAt = _data["CachedAt"] ? new Date(_data["CachedAt"].toString()) : undefined as any;
            this.isCached = _data["IsCached"];
        }
    }

    static fromJS(data: any): CachedAccountSqlStatusResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CachedAccountSqlStatusResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Status"] = this.status ? this.status.toJSON() : undefined as any;
        data["CachedAt"] = this.cachedAt ? this.cachedAt.toISOString() : undefined as any;
        data["IsCached"] = this.isCached;
        return data;
    }
}

export interface ICachedAccountSqlStatusResponse {
    status?: AccountSqlStatusResponse;
    cachedAt?: Date | undefined;
    isCached?: boolean;
}

export class CachedPermissionsOverviewResponse implements ICachedPermissionsOverviewResponse {
    overview?: SqlIntegrationPermissionsOverviewResponse;
    cachedAt?: Date | undefined;
    isCached?: boolean;

    constructor(data?: ICachedPermissionsOverviewResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.overview = _data["Overview"] ? SqlIntegrationPermissionsOverviewResponse.fromJS(_data["Overview"]) : undefined as any;
            this.cachedAt = _data["CachedAt"] ? new Date(_data["CachedAt"].toString()) : undefined as any;
            this.isCached = _data["IsCached"];
        }
    }

    static fromJS(data: any): CachedPermissionsOverviewResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CachedPermissionsOverviewResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Overview"] = this.overview ? this.overview.toJSON() : undefined as any;
        data["CachedAt"] = this.cachedAt ? this.cachedAt.toISOString() : undefined as any;
        data["IsCached"] = this.isCached;
        return data;
    }
}

export interface ICachedPermissionsOverviewResponse {
    overview?: SqlIntegrationPermissionsOverviewResponse;
    cachedAt?: Date | undefined;
    isCached?: boolean;
}

export class CreateAccount implements ICreateAccount {
    targetId?: string;
    targetKind?: TargetKind;
    authKind?: AuthKind;
    secretBinding?: SecretBinding;
    userName?: string | undefined;
    parameters?: { [key: string]: string; } | undefined;
    grants?: Grant[] | undefined;
    tagIds?: string[] | undefined;

    constructor(data?: ICreateAccount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.targetId = _data["TargetId"];
            this.targetKind = _data["TargetKind"];
            this.authKind = _data["AuthKind"];
            this.secretBinding = _data["SecretBinding"] ? SecretBinding.fromJS(_data["SecretBinding"]) : undefined as any;
            this.userName = _data["UserName"];
            if (_data["Parameters"]) {
                this.parameters = {} as any;
                for (let key in _data["Parameters"]) {
                    if (_data["Parameters"].hasOwnProperty(key))
                        (this.parameters as any)![key] = _data["Parameters"][key];
                }
            }
            if (Array.isArray(_data["Grants"])) {
                this.grants = [] as any;
                for (let item of _data["Grants"])
                    this.grants!.push(Grant.fromJS(item));
            }
            if (Array.isArray(_data["TagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["TagIds"])
                    this.tagIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateAccount {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAccount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TargetId"] = this.targetId;
        data["TargetKind"] = this.targetKind;
        data["AuthKind"] = this.authKind;
        data["SecretBinding"] = this.secretBinding ? this.secretBinding.toJSON() : undefined as any;
        data["UserName"] = this.userName;
        if (this.parameters) {
            data["Parameters"] = {};
            for (let key in this.parameters) {
                if (this.parameters.hasOwnProperty(key))
                    (data["Parameters"] as any)[key] = (this.parameters as any)[key];
            }
        }
        if (Array.isArray(this.grants)) {
            data["Grants"] = [];
            for (let item of this.grants)
                data["Grants"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.tagIds)) {
            data["TagIds"] = [];
            for (let item of this.tagIds)
                data["TagIds"].push(item);
        }
        return data;
    }
}

export interface ICreateAccount {
    targetId?: string;
    targetKind?: TargetKind;
    authKind?: AuthKind;
    secretBinding?: SecretBinding;
    userName?: string | undefined;
    parameters?: { [key: string]: string; } | undefined;
    grants?: Grant[] | undefined;
    tagIds?: string[] | undefined;
}

export class CreateAccountGrant implements ICreateAccountGrant {
    accountId?: string;
    database?: string | undefined;
    schema?: string | undefined;
    privileges?: Privilege[] | undefined;

    constructor(data?: ICreateAccountGrant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountId = _data["AccountId"];
            this.database = _data["Database"];
            this.schema = _data["Schema"];
            if (Array.isArray(_data["Privileges"])) {
                this.privileges = [] as any;
                for (let item of _data["Privileges"])
                    this.privileges!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateAccountGrant {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAccountGrant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AccountId"] = this.accountId;
        data["Database"] = this.database;
        data["Schema"] = this.schema;
        if (Array.isArray(this.privileges)) {
            data["Privileges"] = [];
            for (let item of this.privileges)
                data["Privileges"].push(item);
        }
        return data;
    }
}

export interface ICreateAccountGrant {
    accountId?: string;
    database?: string | undefined;
    schema?: string | undefined;
    privileges?: Privilege[] | undefined;
}

export class CreateApplication implements ICreateApplication {
    name?: string | undefined;
    version?: string | undefined;
    description?: string | undefined;
    owner?: string | undefined;
    notes?: string | undefined;
    framework?: string | undefined;
    repositoryUri?: string | undefined;
    icon?: string | undefined;
    tagIds?: string[] | undefined;

    constructor(data?: ICreateApplication) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["Name"];
            this.version = _data["Version"];
            this.description = _data["Description"];
            this.owner = _data["Owner"];
            this.notes = _data["Notes"];
            this.framework = _data["Framework"];
            this.repositoryUri = _data["RepositoryUri"];
            this.icon = _data["Icon"];
            if (Array.isArray(_data["TagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["TagIds"])
                    this.tagIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateApplication {
        data = typeof data === 'object' ? data : {};
        let result = new CreateApplication();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["Version"] = this.version;
        data["Description"] = this.description;
        data["Owner"] = this.owner;
        data["Notes"] = this.notes;
        data["Framework"] = this.framework;
        data["RepositoryUri"] = this.repositoryUri;
        data["Icon"] = this.icon;
        if (Array.isArray(this.tagIds)) {
            data["TagIds"] = [];
            for (let item of this.tagIds)
                data["TagIds"].push(item);
        }
        return data;
    }
}

export interface ICreateApplication {
    name?: string | undefined;
    version?: string | undefined;
    description?: string | undefined;
    owner?: string | undefined;
    notes?: string | undefined;
    framework?: string | undefined;
    repositoryUri?: string | undefined;
    icon?: string | undefined;
    tagIds?: string[] | undefined;
}

export class CreateApplicationDependency implements ICreateApplicationDependency {
    applicationId?: string;
    instanceId?: string;
    targetId?: string;
    targetKind?: TargetKind;
    port?: number | undefined;
    authKind?: DependencyAuthKind;
    accountId?: string | undefined;
    identityId?: string | undefined;

    constructor(data?: ICreateApplicationDependency) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.applicationId = _data["ApplicationId"];
            this.instanceId = _data["InstanceId"];
            this.targetId = _data["TargetId"];
            this.targetKind = _data["TargetKind"];
            this.port = _data["Port"];
            this.authKind = _data["AuthKind"];
            this.accountId = _data["AccountId"];
            this.identityId = _data["IdentityId"];
        }
    }

    static fromJS(data: any): CreateApplicationDependency {
        data = typeof data === 'object' ? data : {};
        let result = new CreateApplicationDependency();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ApplicationId"] = this.applicationId;
        data["InstanceId"] = this.instanceId;
        data["TargetId"] = this.targetId;
        data["TargetKind"] = this.targetKind;
        data["Port"] = this.port;
        data["AuthKind"] = this.authKind;
        data["AccountId"] = this.accountId;
        data["IdentityId"] = this.identityId;
        return data;
    }
}

export interface ICreateApplicationDependency {
    applicationId?: string;
    instanceId?: string;
    targetId?: string;
    targetKind?: TargetKind;
    port?: number | undefined;
    authKind?: DependencyAuthKind;
    accountId?: string | undefined;
    identityId?: string | undefined;
}

export class CreateApplicationInstance implements ICreateApplicationInstance {
    applicationId?: string;
    environmentId?: string;
    platformId?: string | undefined;
    baseUri?: string | undefined;
    healthUri?: string | undefined;
    openApiUri?: string | undefined;
    version?: string | undefined;
    tagIds?: string[] | undefined;

    constructor(data?: ICreateApplicationInstance) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.applicationId = _data["ApplicationId"];
            this.environmentId = _data["EnvironmentId"];
            this.platformId = _data["PlatformId"];
            this.baseUri = _data["BaseUri"];
            this.healthUri = _data["HealthUri"];
            this.openApiUri = _data["OpenApiUri"];
            this.version = _data["Version"];
            if (Array.isArray(_data["TagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["TagIds"])
                    this.tagIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateApplicationInstance {
        data = typeof data === 'object' ? data : {};
        let result = new CreateApplicationInstance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ApplicationId"] = this.applicationId;
        data["EnvironmentId"] = this.environmentId;
        data["PlatformId"] = this.platformId;
        data["BaseUri"] = this.baseUri;
        data["HealthUri"] = this.healthUri;
        data["OpenApiUri"] = this.openApiUri;
        data["Version"] = this.version;
        if (Array.isArray(this.tagIds)) {
            data["TagIds"] = [];
            for (let item of this.tagIds)
                data["TagIds"].push(item);
        }
        return data;
    }
}

export interface ICreateApplicationInstance {
    applicationId?: string;
    environmentId?: string;
    platformId?: string | undefined;
    baseUri?: string | undefined;
    healthUri?: string | undefined;
    openApiUri?: string | undefined;
    version?: string | undefined;
    tagIds?: string[] | undefined;
}

export class CreateApplicationPipeline implements ICreateApplicationPipeline {
    applicationId?: string;
    name?: string | undefined;
    pipelineUri?: string | undefined;

    constructor(data?: ICreateApplicationPipeline) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.applicationId = _data["ApplicationId"];
            this.name = _data["Name"];
            this.pipelineUri = _data["PipelineUri"];
        }
    }

    static fromJS(data: any): CreateApplicationPipeline {
        data = typeof data === 'object' ? data : {};
        let result = new CreateApplicationPipeline();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ApplicationId"] = this.applicationId;
        data["Name"] = this.name;
        data["PipelineUri"] = this.pipelineUri;
        return data;
    }
}

export interface ICreateApplicationPipeline {
    applicationId?: string;
    name?: string | undefined;
    pipelineUri?: string | undefined;
}

export class CreateDataStore implements ICreateDataStore {
    name?: string | undefined;
    kind?: string | undefined;
    environmentId?: string;
    platformId?: string | undefined;
    connectionUri?: string | undefined;
    tagIds?: string[] | undefined;

    constructor(data?: ICreateDataStore) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["Name"];
            this.kind = _data["Kind"];
            this.environmentId = _data["EnvironmentId"];
            this.platformId = _data["PlatformId"];
            this.connectionUri = _data["ConnectionUri"];
            if (Array.isArray(_data["TagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["TagIds"])
                    this.tagIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateDataStore {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDataStore();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["Kind"] = this.kind;
        data["EnvironmentId"] = this.environmentId;
        data["PlatformId"] = this.platformId;
        data["ConnectionUri"] = this.connectionUri;
        if (Array.isArray(this.tagIds)) {
            data["TagIds"] = [];
            for (let item of this.tagIds)
                data["TagIds"].push(item);
        }
        return data;
    }
}

export interface ICreateDataStore {
    name?: string | undefined;
    kind?: string | undefined;
    environmentId?: string;
    platformId?: string | undefined;
    connectionUri?: string | undefined;
    tagIds?: string[] | undefined;
}

export class CreateEnvironment implements ICreateEnvironment {
    name?: string | undefined;
    description?: string | undefined;
    tagIds?: string[] | undefined;
    autoCreateInstances?: boolean;
    baseUriTemplate?: string | undefined;
    healthUriTemplate?: string | undefined;
    openApiUriTemplate?: string | undefined;

    constructor(data?: ICreateEnvironment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["Name"];
            this.description = _data["Description"];
            if (Array.isArray(_data["TagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["TagIds"])
                    this.tagIds!.push(item);
            }
            this.autoCreateInstances = _data["AutoCreateInstances"];
            this.baseUriTemplate = _data["BaseUriTemplate"];
            this.healthUriTemplate = _data["HealthUriTemplate"];
            this.openApiUriTemplate = _data["OpenApiUriTemplate"];
        }
    }

    static fromJS(data: any): CreateEnvironment {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEnvironment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["Description"] = this.description;
        if (Array.isArray(this.tagIds)) {
            data["TagIds"] = [];
            for (let item of this.tagIds)
                data["TagIds"].push(item);
        }
        data["AutoCreateInstances"] = this.autoCreateInstances;
        data["BaseUriTemplate"] = this.baseUriTemplate;
        data["HealthUriTemplate"] = this.healthUriTemplate;
        data["OpenApiUriTemplate"] = this.openApiUriTemplate;
        return data;
    }
}

export interface ICreateEnvironment {
    name?: string | undefined;
    description?: string | undefined;
    tagIds?: string[] | undefined;
    autoCreateInstances?: boolean;
    baseUriTemplate?: string | undefined;
    healthUriTemplate?: string | undefined;
    openApiUriTemplate?: string | undefined;
}

export class CreateExternalResource implements ICreateExternalResource {
    name?: string | undefined;
    description?: string | undefined;
    resourceUri?: string | undefined;
    tagIds?: string[] | undefined;

    constructor(data?: ICreateExternalResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["Name"];
            this.description = _data["Description"];
            this.resourceUri = _data["ResourceUri"];
            if (Array.isArray(_data["TagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["TagIds"])
                    this.tagIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateExternalResource {
        data = typeof data === 'object' ? data : {};
        let result = new CreateExternalResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["Description"] = this.description;
        data["ResourceUri"] = this.resourceUri;
        if (Array.isArray(this.tagIds)) {
            data["TagIds"] = [];
            for (let item of this.tagIds)
                data["TagIds"].push(item);
        }
        return data;
    }
}

export interface ICreateExternalResource {
    name?: string | undefined;
    description?: string | undefined;
    resourceUri?: string | undefined;
    tagIds?: string[] | undefined;
}

export class CreateIdentity implements ICreateIdentity {
    name?: string | undefined;
    kind?: IdentityKind;
    notes?: string | undefined;
    ownerInstanceId?: string | undefined;
    assignments?: IdentityAssignment[] | undefined;
    tagIds?: string[] | undefined;

    constructor(data?: ICreateIdentity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["Name"];
            this.kind = _data["Kind"];
            this.notes = _data["Notes"];
            this.ownerInstanceId = _data["OwnerInstanceId"];
            if (Array.isArray(_data["Assignments"])) {
                this.assignments = [] as any;
                for (let item of _data["Assignments"])
                    this.assignments!.push(IdentityAssignment.fromJS(item));
            }
            if (Array.isArray(_data["TagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["TagIds"])
                    this.tagIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateIdentity {
        data = typeof data === 'object' ? data : {};
        let result = new CreateIdentity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["Kind"] = this.kind;
        data["Notes"] = this.notes;
        data["OwnerInstanceId"] = this.ownerInstanceId;
        if (Array.isArray(this.assignments)) {
            data["Assignments"] = [];
            for (let item of this.assignments)
                data["Assignments"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.tagIds)) {
            data["TagIds"] = [];
            for (let item of this.tagIds)
                data["TagIds"].push(item);
        }
        return data;
    }
}

export interface ICreateIdentity {
    name?: string | undefined;
    kind?: IdentityKind;
    notes?: string | undefined;
    ownerInstanceId?: string | undefined;
    assignments?: IdentityAssignment[] | undefined;
    tagIds?: string[] | undefined;
}

export class CreateIdentityAssignment implements ICreateIdentityAssignment {
    identityId?: string;
    targetKind?: TargetKind;
    targetId?: string;
    role?: string | undefined;
    notes?: string | undefined;

    constructor(data?: ICreateIdentityAssignment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.identityId = _data["IdentityId"];
            this.targetKind = _data["TargetKind"];
            this.targetId = _data["TargetId"];
            this.role = _data["Role"];
            this.notes = _data["Notes"];
        }
    }

    static fromJS(data: any): CreateIdentityAssignment {
        data = typeof data === 'object' ? data : {};
        let result = new CreateIdentityAssignment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["IdentityId"] = this.identityId;
        data["TargetKind"] = this.targetKind;
        data["TargetId"] = this.targetId;
        data["Role"] = this.role;
        data["Notes"] = this.notes;
        return data;
    }
}

export interface ICreateIdentityAssignment {
    identityId?: string;
    targetKind?: TargetKind;
    targetId?: string;
    role?: string | undefined;
    notes?: string | undefined;
}

export class CreateKumaIntegration implements ICreateKumaIntegration {
    name?: string | undefined;
    environmentIds?: string[] | undefined;
    platformId?: string | undefined;
    accountId?: string | undefined;
    uri?: string | undefined;
    apiKey?: string | undefined;

    constructor(data?: ICreateKumaIntegration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["Name"];
            if (Array.isArray(_data["EnvironmentIds"])) {
                this.environmentIds = [] as any;
                for (let item of _data["EnvironmentIds"])
                    this.environmentIds!.push(item);
            }
            this.platformId = _data["PlatformId"];
            this.accountId = _data["AccountId"];
            this.uri = _data["Uri"];
            this.apiKey = _data["ApiKey"];
        }
    }

    static fromJS(data: any): CreateKumaIntegration {
        data = typeof data === 'object' ? data : {};
        let result = new CreateKumaIntegration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        if (Array.isArray(this.environmentIds)) {
            data["EnvironmentIds"] = [];
            for (let item of this.environmentIds)
                data["EnvironmentIds"].push(item);
        }
        data["PlatformId"] = this.platformId;
        data["AccountId"] = this.accountId;
        data["Uri"] = this.uri;
        data["ApiKey"] = this.apiKey;
        return data;
    }
}

export interface ICreateKumaIntegration {
    name?: string | undefined;
    environmentIds?: string[] | undefined;
    platformId?: string | undefined;
    accountId?: string | undefined;
    uri?: string | undefined;
    apiKey?: string | undefined;
}

export class CreatePlatform implements ICreatePlatform {
    displayName?: string | undefined;
    dnsName?: string | undefined;
    os?: string | undefined;
    kind?: PlatformKind;
    ipAddress?: string | undefined;
    notes?: string | undefined;
    tagIds?: string[] | undefined;

    constructor(data?: ICreatePlatform) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["DisplayName"];
            this.dnsName = _data["DnsName"];
            this.os = _data["Os"];
            this.kind = _data["Kind"];
            this.ipAddress = _data["IpAddress"];
            this.notes = _data["Notes"];
            if (Array.isArray(_data["TagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["TagIds"])
                    this.tagIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CreatePlatform {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePlatform();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DisplayName"] = this.displayName;
        data["DnsName"] = this.dnsName;
        data["Os"] = this.os;
        data["Kind"] = this.kind;
        data["IpAddress"] = this.ipAddress;
        data["Notes"] = this.notes;
        if (Array.isArray(this.tagIds)) {
            data["TagIds"] = [];
            for (let item of this.tagIds)
                data["TagIds"].push(item);
        }
        return data;
    }
}

export interface ICreatePlatform {
    displayName?: string | undefined;
    dnsName?: string | undefined;
    os?: string | undefined;
    kind?: PlatformKind;
    ipAddress?: string | undefined;
    notes?: string | undefined;
    tagIds?: string[] | undefined;
}

export class CreateSecret implements ICreateSecret {
    providerId?: string;
    secretName?: string | undefined;
    secretValue?: string | undefined;

    constructor(data?: ICreateSecret) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.providerId = _data["ProviderId"];
            this.secretName = _data["SecretName"];
            this.secretValue = _data["SecretValue"];
        }
    }

    static fromJS(data: any): CreateSecret {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSecret();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ProviderId"] = this.providerId;
        data["SecretName"] = this.secretName;
        data["SecretValue"] = this.secretValue;
        return data;
    }
}

export interface ICreateSecret {
    providerId?: string;
    secretName?: string | undefined;
    secretValue?: string | undefined;
}

export class CreateSecretProvider implements ICreateSecretProvider {
    name?: string | undefined;
    vaultUri?: string | undefined;
    authMode?: SecretProviderAuthMode;
    credentials?: SecretProviderCredentials;
    capabilities?: SecretProviderCapabilities;

    constructor(data?: ICreateSecretProvider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["Name"];
            this.vaultUri = _data["VaultUri"];
            this.authMode = _data["AuthMode"];
            this.credentials = _data["Credentials"] ? SecretProviderCredentials.fromJS(_data["Credentials"]) : undefined as any;
            this.capabilities = _data["Capabilities"];
        }
    }

    static fromJS(data: any): CreateSecretProvider {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSecretProvider();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["VaultUri"] = this.vaultUri;
        data["AuthMode"] = this.authMode;
        data["Credentials"] = this.credentials ? this.credentials.toJSON() : undefined as any;
        data["Capabilities"] = this.capabilities;
        return data;
    }
}

export interface ICreateSecretProvider {
    name?: string | undefined;
    vaultUri?: string | undefined;
    authMode?: SecretProviderAuthMode;
    credentials?: SecretProviderCredentials;
    capabilities?: SecretProviderCapabilities;
}

export class CreateSecurityUser implements ICreateSecurityUser {
    userName?: string | undefined;
    password?: string | undefined;
    role?: SecurityRole;
    requestedBy?: string | undefined;

    constructor(data?: ICreateSecurityUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["UserName"];
            this.password = _data["Password"];
            this.role = _data["Role"];
            this.requestedBy = _data["RequestedBy"];
        }
    }

    static fromJS(data: any): CreateSecurityUser {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSecurityUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserName"] = this.userName;
        data["Password"] = this.password;
        data["Role"] = this.role;
        data["RequestedBy"] = this.requestedBy;
        return data;
    }
}

export interface ICreateSecurityUser {
    userName?: string | undefined;
    password?: string | undefined;
    role?: SecurityRole;
    requestedBy?: string | undefined;
}

export class CreateSqlAccountRequest implements ICreateSqlAccountRequest {
    passwordSource?: PasswordSource;
    password?: string | undefined;

    constructor(data?: ICreateSqlAccountRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.passwordSource = _data["PasswordSource"];
            this.password = _data["Password"];
        }
    }

    static fromJS(data: any): CreateSqlAccountRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSqlAccountRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PasswordSource"] = this.passwordSource;
        data["Password"] = this.password;
        return data;
    }
}

export interface ICreateSqlAccountRequest {
    passwordSource?: PasswordSource;
    password?: string | undefined;
}

export class CreateSqlAccountResponse implements ICreateSqlAccountResponse {
    accountId?: string;
    principalName?: string | undefined;
    success?: boolean;
    passwordSource?: PasswordSourceUsed;
    operations?: SqlAccountCreationOperation[] | undefined;
    updatedStatus?: SqlAccountPermissionsStatus;
    errorMessage?: string | undefined;

    constructor(data?: ICreateSqlAccountResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountId = _data["AccountId"];
            this.principalName = _data["PrincipalName"];
            this.success = _data["Success"];
            this.passwordSource = _data["PasswordSource"];
            if (Array.isArray(_data["Operations"])) {
                this.operations = [] as any;
                for (let item of _data["Operations"])
                    this.operations!.push(SqlAccountCreationOperation.fromJS(item));
            }
            this.updatedStatus = _data["UpdatedStatus"] ? SqlAccountPermissionsStatus.fromJS(_data["UpdatedStatus"]) : undefined as any;
            this.errorMessage = _data["ErrorMessage"];
        }
    }

    static fromJS(data: any): CreateSqlAccountResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSqlAccountResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AccountId"] = this.accountId;
        data["PrincipalName"] = this.principalName;
        data["Success"] = this.success;
        data["PasswordSource"] = this.passwordSource;
        if (Array.isArray(this.operations)) {
            data["Operations"] = [];
            for (let item of this.operations)
                data["Operations"].push(item ? item.toJSON() : undefined as any);
        }
        data["UpdatedStatus"] = this.updatedStatus ? this.updatedStatus.toJSON() : undefined as any;
        data["ErrorMessage"] = this.errorMessage;
        return data;
    }
}

export interface ICreateSqlAccountResponse {
    accountId?: string;
    principalName?: string | undefined;
    success?: boolean;
    passwordSource?: PasswordSourceUsed;
    operations?: SqlAccountCreationOperation[] | undefined;
    updatedStatus?: SqlAccountPermissionsStatus;
    errorMessage?: string | undefined;
}

export class CreateSqlIntegration implements ICreateSqlIntegration {
    name?: string | undefined;
    dataStoreId?: string;
    connectionString?: string | undefined;

    constructor(data?: ICreateSqlIntegration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["Name"];
            this.dataStoreId = _data["DataStoreId"];
            this.connectionString = _data["ConnectionString"];
        }
    }

    static fromJS(data: any): CreateSqlIntegration {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSqlIntegration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["DataStoreId"] = this.dataStoreId;
        data["ConnectionString"] = this.connectionString;
        return data;
    }
}

export interface ICreateSqlIntegration {
    name?: string | undefined;
    dataStoreId?: string;
    connectionString?: string | undefined;
}

export class CreateTag implements ICreateTag {
    name?: string | undefined;
    description?: string | undefined;
    color?: TagColor;

    constructor(data?: ICreateTag) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["Name"];
            this.description = _data["Description"];
            this.color = _data["Color"];
        }
    }

    static fromJS(data: any): CreateTag {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTag();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["Description"] = this.description;
        data["Color"] = this.color;
        return data;
    }
}

export interface ICreateTag {
    name?: string | undefined;
    description?: string | undefined;
    color?: TagColor;
}

export class DataStore implements IDataStore {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    kind?: string | undefined;
    environmentId?: string;
    platformId?: string | undefined;
    connectionUri?: string | undefined;
    tagIds?: string[] | undefined;
    createdAt?: Date;
    updatedAt?: Date;

    constructor(data?: IDataStore) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.description = _data["Description"];
            this.kind = _data["Kind"];
            this.environmentId = _data["EnvironmentId"];
            this.platformId = _data["PlatformId"];
            this.connectionUri = _data["ConnectionUri"];
            if (Array.isArray(_data["TagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["TagIds"])
                    this.tagIds!.push(item);
            }
            this.createdAt = _data["CreatedAt"] ? new Date(_data["CreatedAt"].toString()) : undefined as any;
            this.updatedAt = _data["UpdatedAt"] ? new Date(_data["UpdatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): DataStore {
        data = typeof data === 'object' ? data : {};
        let result = new DataStore();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Description"] = this.description;
        data["Kind"] = this.kind;
        data["EnvironmentId"] = this.environmentId;
        data["PlatformId"] = this.platformId;
        data["ConnectionUri"] = this.connectionUri;
        if (Array.isArray(this.tagIds)) {
            data["TagIds"] = [];
            for (let item of this.tagIds)
                data["TagIds"].push(item);
        }
        data["CreatedAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IDataStore {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    kind?: string | undefined;
    environmentId?: string;
    platformId?: string | undefined;
    connectionUri?: string | undefined;
    tagIds?: string[] | undefined;
    createdAt?: Date;
    updatedAt?: Date;
}

export enum DependencyAuthKind {
    None = "None",
    Account = "Account",
    Identity = "Identity",
}

export class DriftResolutionOperation implements IDriftResolutionOperation {
    operationType?: string | undefined;
    database?: string | undefined;
    schema?: string | undefined;
    privilege?: Privilege;
    success?: boolean;
    errorMessage?: string | undefined;

    constructor(data?: IDriftResolutionOperation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.operationType = _data["OperationType"];
            this.database = _data["Database"];
            this.schema = _data["Schema"];
            this.privilege = _data["Privilege"];
            this.success = _data["Success"];
            this.errorMessage = _data["ErrorMessage"];
        }
    }

    static fromJS(data: any): DriftResolutionOperation {
        data = typeof data === 'object' ? data : {};
        let result = new DriftResolutionOperation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["OperationType"] = this.operationType;
        data["Database"] = this.database;
        data["Schema"] = this.schema;
        data["Privilege"] = this.privilege;
        data["Success"] = this.success;
        data["ErrorMessage"] = this.errorMessage;
        return data;
    }
}

export interface IDriftResolutionOperation {
    operationType?: string | undefined;
    database?: string | undefined;
    schema?: string | undefined;
    privilege?: Privilege;
    success?: boolean;
    errorMessage?: string | undefined;
}

export class EnvironmentInfo implements IEnvironmentInfo {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    tagIds?: string[] | undefined;
    autoCreateInstances?: boolean;
    baseUriTemplate?: string | undefined;
    healthUriTemplate?: string | undefined;
    openApiUriTemplate?: string | undefined;

    constructor(data?: IEnvironmentInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.description = _data["Description"];
            if (Array.isArray(_data["TagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["TagIds"])
                    this.tagIds!.push(item);
            }
            this.autoCreateInstances = _data["AutoCreateInstances"];
            this.baseUriTemplate = _data["BaseUriTemplate"];
            this.healthUriTemplate = _data["HealthUriTemplate"];
            this.openApiUriTemplate = _data["OpenApiUriTemplate"];
        }
    }

    static fromJS(data: any): EnvironmentInfo {
        data = typeof data === 'object' ? data : {};
        let result = new EnvironmentInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Description"] = this.description;
        if (Array.isArray(this.tagIds)) {
            data["TagIds"] = [];
            for (let item of this.tagIds)
                data["TagIds"].push(item);
        }
        data["AutoCreateInstances"] = this.autoCreateInstances;
        data["BaseUriTemplate"] = this.baseUriTemplate;
        data["HealthUriTemplate"] = this.healthUriTemplate;
        data["OpenApiUriTemplate"] = this.openApiUriTemplate;
        return data;
    }
}

export interface IEnvironmentInfo {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    tagIds?: string[] | undefined;
    autoCreateInstances?: boolean;
    baseUriTemplate?: string | undefined;
    healthUriTemplate?: string | undefined;
    openApiUriTemplate?: string | undefined;
}

export class ExternalResource implements IExternalResource {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    resourceUri?: string | undefined;
    tagIds?: string[] | undefined;
    createdAt?: Date;
    updatedAt?: Date;

    constructor(data?: IExternalResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.description = _data["Description"];
            this.resourceUri = _data["ResourceUri"];
            if (Array.isArray(_data["TagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["TagIds"])
                    this.tagIds!.push(item);
            }
            this.createdAt = _data["CreatedAt"] ? new Date(_data["CreatedAt"].toString()) : undefined as any;
            this.updatedAt = _data["UpdatedAt"] ? new Date(_data["UpdatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): ExternalResource {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Description"] = this.description;
        data["ResourceUri"] = this.resourceUri;
        if (Array.isArray(this.tagIds)) {
            data["TagIds"] = [];
            for (let item of this.tagIds)
                data["TagIds"].push(item);
        }
        data["CreatedAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IExternalResource {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    resourceUri?: string | undefined;
    tagIds?: string[] | undefined;
    createdAt?: Date;
    updatedAt?: Date;
}

export class Grant implements IGrant {
    id?: string;
    database?: string | undefined;
    schema?: string | undefined;
    privileges?: Privilege[] | undefined;

    constructor(data?: IGrant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.database = _data["Database"];
            this.schema = _data["Schema"];
            if (Array.isArray(_data["Privileges"])) {
                this.privileges = [] as any;
                for (let item of _data["Privileges"])
                    this.privileges!.push(item);
            }
        }
    }

    static fromJS(data: any): Grant {
        data = typeof data === 'object' ? data : {};
        let result = new Grant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Database"] = this.database;
        data["Schema"] = this.schema;
        if (Array.isArray(this.privileges)) {
            data["Privileges"] = [];
            for (let item of this.privileges)
                data["Privileges"].push(item);
        }
        return data;
    }
}

export interface IGrant {
    id?: string;
    database?: string | undefined;
    schema?: string | undefined;
    privileges?: Privilege[] | undefined;
}

export class HealthStatusResponse implements IHealthStatusResponse {
    monitorUrl?: string | undefined;
    status?: MonitorStatus;
    monitorName?: string | undefined;
    lastChecked?: Date;

    constructor(data?: IHealthStatusResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.monitorUrl = _data["MonitorUrl"];
            this.status = _data["Status"];
            this.monitorName = _data["MonitorName"];
            this.lastChecked = _data["LastChecked"] ? new Date(_data["LastChecked"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): HealthStatusResponse {
        data = typeof data === 'object' ? data : {};
        let result = new HealthStatusResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["MonitorUrl"] = this.monitorUrl;
        data["Status"] = this.status;
        data["MonitorName"] = this.monitorName;
        data["LastChecked"] = this.lastChecked ? this.lastChecked.toISOString() : undefined as any;
        return data;
    }
}

export interface IHealthStatusResponse {
    monitorUrl?: string | undefined;
    status?: MonitorStatus;
    monitorName?: string | undefined;
    lastChecked?: Date;
}

export class Identity implements IIdentity {
    id?: string;
    name?: string | undefined;
    kind?: IdentityKind;
    notes?: string | undefined;
    ownerInstanceId?: string | undefined;
    assignments?: IdentityAssignment[] | undefined;
    tagIds?: string[] | undefined;
    createdAt?: Date;
    updatedAt?: Date;

    constructor(data?: IIdentity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.kind = _data["Kind"];
            this.notes = _data["Notes"];
            this.ownerInstanceId = _data["OwnerInstanceId"];
            if (Array.isArray(_data["Assignments"])) {
                this.assignments = [] as any;
                for (let item of _data["Assignments"])
                    this.assignments!.push(IdentityAssignment.fromJS(item));
            }
            if (Array.isArray(_data["TagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["TagIds"])
                    this.tagIds!.push(item);
            }
            this.createdAt = _data["CreatedAt"] ? new Date(_data["CreatedAt"].toString()) : undefined as any;
            this.updatedAt = _data["UpdatedAt"] ? new Date(_data["UpdatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): Identity {
        data = typeof data === 'object' ? data : {};
        let result = new Identity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Kind"] = this.kind;
        data["Notes"] = this.notes;
        data["OwnerInstanceId"] = this.ownerInstanceId;
        if (Array.isArray(this.assignments)) {
            data["Assignments"] = [];
            for (let item of this.assignments)
                data["Assignments"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.tagIds)) {
            data["TagIds"] = [];
            for (let item of this.tagIds)
                data["TagIds"].push(item);
        }
        data["CreatedAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IIdentity {
    id?: string;
    name?: string | undefined;
    kind?: IdentityKind;
    notes?: string | undefined;
    ownerInstanceId?: string | undefined;
    assignments?: IdentityAssignment[] | undefined;
    tagIds?: string[] | undefined;
    createdAt?: Date;
    updatedAt?: Date;
}

export class IdentityAssignment implements IIdentityAssignment {
    id?: string;
    targetKind?: TargetKind;
    targetId?: string;
    role?: string | undefined;
    notes?: string | undefined;

    constructor(data?: IIdentityAssignment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.targetKind = _data["TargetKind"];
            this.targetId = _data["TargetId"];
            this.role = _data["Role"];
            this.notes = _data["Notes"];
        }
    }

    static fromJS(data: any): IdentityAssignment {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityAssignment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["TargetKind"] = this.targetKind;
        data["TargetId"] = this.targetId;
        data["Role"] = this.role;
        data["Notes"] = this.notes;
        return data;
    }
}

export interface IIdentityAssignment {
    id?: string;
    targetKind?: TargetKind;
    targetId?: string;
    role?: string | undefined;
    notes?: string | undefined;
}

export enum IdentityKind {
    AzureManagedIdentity = "AzureManagedIdentity",
    KubernetesServiceAccount = "KubernetesServiceAccount",
    AwsIamRole = "AwsIamRole",
    Custom = "Custom",
}

export class ImportOrphanPrincipalRequest implements IImportOrphanPrincipalRequest {
    principalName?: string | undefined;
    authKind?: AuthKind;
    secretBinding?: SecretBinding;

    constructor(data?: IImportOrphanPrincipalRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.principalName = _data["PrincipalName"];
            this.authKind = _data["AuthKind"];
            this.secretBinding = _data["SecretBinding"] ? SecretBinding.fromJS(_data["SecretBinding"]) : undefined as any;
        }
    }

    static fromJS(data: any): ImportOrphanPrincipalRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ImportOrphanPrincipalRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PrincipalName"] = this.principalName;
        data["AuthKind"] = this.authKind;
        data["SecretBinding"] = this.secretBinding ? this.secretBinding.toJSON() : undefined as any;
        return data;
    }
}

export interface IImportOrphanPrincipalRequest {
    principalName?: string | undefined;
    authKind?: AuthKind;
    secretBinding?: SecretBinding;
}

export class ImportOrphanPrincipalResponse implements IImportOrphanPrincipalResponse {
    accountId?: string;
    principalName?: string | undefined;
    success?: boolean;
    importedGrants?: Grant[] | undefined;
    errorMessage?: string | undefined;

    constructor(data?: IImportOrphanPrincipalResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountId = _data["AccountId"];
            this.principalName = _data["PrincipalName"];
            this.success = _data["Success"];
            if (Array.isArray(_data["ImportedGrants"])) {
                this.importedGrants = [] as any;
                for (let item of _data["ImportedGrants"])
                    this.importedGrants!.push(Grant.fromJS(item));
            }
            this.errorMessage = _data["ErrorMessage"];
        }
    }

    static fromJS(data: any): ImportOrphanPrincipalResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ImportOrphanPrincipalResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AccountId"] = this.accountId;
        data["PrincipalName"] = this.principalName;
        data["Success"] = this.success;
        if (Array.isArray(this.importedGrants)) {
            data["ImportedGrants"] = [];
            for (let item of this.importedGrants)
                data["ImportedGrants"].push(item ? item.toJSON() : undefined as any);
        }
        data["ErrorMessage"] = this.errorMessage;
        return data;
    }
}

export interface IImportOrphanPrincipalResponse {
    accountId?: string;
    principalName?: string | undefined;
    success?: boolean;
    importedGrants?: Grant[] | undefined;
    errorMessage?: string | undefined;
}

export class ImportPermissionsResponse implements IImportPermissionsResponse {
    accountId?: string;
    principalName?: string | undefined;
    success?: boolean;
    importedGrants?: Grant[] | undefined;
    updatedStatus?: SqlAccountPermissionsStatus;
    errorMessage?: string | undefined;

    constructor(data?: IImportPermissionsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountId = _data["AccountId"];
            this.principalName = _data["PrincipalName"];
            this.success = _data["Success"];
            if (Array.isArray(_data["ImportedGrants"])) {
                this.importedGrants = [] as any;
                for (let item of _data["ImportedGrants"])
                    this.importedGrants!.push(Grant.fromJS(item));
            }
            this.updatedStatus = _data["UpdatedStatus"] ? SqlAccountPermissionsStatus.fromJS(_data["UpdatedStatus"]) : undefined as any;
            this.errorMessage = _data["ErrorMessage"];
        }
    }

    static fromJS(data: any): ImportPermissionsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ImportPermissionsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AccountId"] = this.accountId;
        data["PrincipalName"] = this.principalName;
        data["Success"] = this.success;
        if (Array.isArray(this.importedGrants)) {
            data["ImportedGrants"] = [];
            for (let item of this.importedGrants)
                data["ImportedGrants"].push(item ? item.toJSON() : undefined as any);
        }
        data["UpdatedStatus"] = this.updatedStatus ? this.updatedStatus.toJSON() : undefined as any;
        data["ErrorMessage"] = this.errorMessage;
        return data;
    }
}

export interface IImportPermissionsResponse {
    accountId?: string;
    principalName?: string | undefined;
    success?: boolean;
    importedGrants?: Grant[] | undefined;
    updatedStatus?: SqlAccountPermissionsStatus;
    errorMessage?: string | undefined;
}

export class KumaIntegrationResponse implements IKumaIntegrationResponse {
    id?: string;
    name?: string | undefined;
    environmentIds?: string[] | undefined;
    platformId?: string | undefined;
    accountId?: string | undefined;
    uri?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date;

    constructor(data?: IKumaIntegrationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            if (Array.isArray(_data["EnvironmentIds"])) {
                this.environmentIds = [] as any;
                for (let item of _data["EnvironmentIds"])
                    this.environmentIds!.push(item);
            }
            this.platformId = _data["PlatformId"];
            this.accountId = _data["AccountId"];
            this.uri = _data["Uri"];
            this.createdAt = _data["CreatedAt"] ? new Date(_data["CreatedAt"].toString()) : undefined as any;
            this.updatedAt = _data["UpdatedAt"] ? new Date(_data["UpdatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): KumaIntegrationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new KumaIntegrationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        if (Array.isArray(this.environmentIds)) {
            data["EnvironmentIds"] = [];
            for (let item of this.environmentIds)
                data["EnvironmentIds"].push(item);
        }
        data["PlatformId"] = this.platformId;
        data["AccountId"] = this.accountId;
        data["Uri"] = this.uri;
        data["CreatedAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IKumaIntegrationResponse {
    id?: string;
    name?: string | undefined;
    environmentIds?: string[] | undefined;
    platformId?: string | undefined;
    accountId?: string | undefined;
    uri?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date;
}

export class LoginSecurityUser implements ILoginSecurityUser {
    userName?: string | undefined;
    password?: string | undefined;

    constructor(data?: ILoginSecurityUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["UserName"];
            this.password = _data["Password"];
        }
    }

    static fromJS(data: any): LoginSecurityUser {
        data = typeof data === 'object' ? data : {};
        let result = new LoginSecurityUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserName"] = this.userName;
        data["Password"] = this.password;
        return data;
    }
}

export interface ILoginSecurityUser {
    userName?: string | undefined;
    password?: string | undefined;
}

export class LoginSession implements ILoginSession {
    token?: string | undefined;
    expiresAt?: Date;
    user?: SecurityUserInfo;

    constructor(data?: ILoginSession) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["Token"];
            this.expiresAt = _data["ExpiresAt"] ? new Date(_data["ExpiresAt"].toString()) : undefined as any;
            this.user = _data["User"] ? SecurityUserInfo.fromJS(_data["User"]) : undefined as any;
        }
    }

    static fromJS(data: any): LoginSession {
        data = typeof data === 'object' ? data : {};
        let result = new LoginSession();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Token"] = this.token;
        data["ExpiresAt"] = this.expiresAt ? this.expiresAt.toISOString() : undefined as any;
        data["User"] = this.user ? this.user.toJSON() : undefined as any;
        return data;
    }
}

export interface ILoginSession {
    token?: string | undefined;
    expiresAt?: Date;
    user?: SecurityUserInfo;
}

export class LogoutSecurityUser implements ILogoutSecurityUser {
    token?: string | undefined;

    constructor(data?: ILogoutSecurityUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["Token"];
        }
    }

    static fromJS(data: any): LogoutSecurityUser {
        data = typeof data === 'object' ? data : {};
        let result = new LogoutSecurityUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Token"] = this.token;
        return data;
    }
}

export interface ILogoutSecurityUser {
    token?: string | undefined;
}

export enum MonitorStatus {
    Down = "Down",
    Up = "Up",
    Pending = "Pending",
    Maintenance = "Maintenance",
}

export enum PasswordSource {
    SecretProvider = "SecretProvider",
    Manual = "Manual",
    NewSecret = "NewSecret",
}

export enum PasswordSourceUsed {
    SecretProvider = "SecretProvider",
    Manual = "Manual",
    NewSecret = "NewSecret",
}

export class Platform implements IPlatform {
    id?: string;
    displayName?: string | undefined;
    dnsName?: string | undefined;
    os?: string | undefined;
    kind?: PlatformKind;
    ipAddress?: string | undefined;
    notes?: string | undefined;
    tagIds?: string[] | undefined;
    createdAt?: Date;
    updatedAt?: Date;

    constructor(data?: IPlatform) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.displayName = _data["DisplayName"];
            this.dnsName = _data["DnsName"];
            this.os = _data["Os"];
            this.kind = _data["Kind"];
            this.ipAddress = _data["IpAddress"];
            this.notes = _data["Notes"];
            if (Array.isArray(_data["TagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["TagIds"])
                    this.tagIds!.push(item);
            }
            this.createdAt = _data["CreatedAt"] ? new Date(_data["CreatedAt"].toString()) : undefined as any;
            this.updatedAt = _data["UpdatedAt"] ? new Date(_data["UpdatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): Platform {
        data = typeof data === 'object' ? data : {};
        let result = new Platform();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["DisplayName"] = this.displayName;
        data["DnsName"] = this.dnsName;
        data["Os"] = this.os;
        data["Kind"] = this.kind;
        data["IpAddress"] = this.ipAddress;
        data["Notes"] = this.notes;
        if (Array.isArray(this.tagIds)) {
            data["TagIds"] = [];
            for (let item of this.tagIds)
                data["TagIds"].push(item);
        }
        data["CreatedAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IPlatform {
    id?: string;
    displayName?: string | undefined;
    dnsName?: string | undefined;
    os?: string | undefined;
    kind?: PlatformKind;
    ipAddress?: string | undefined;
    notes?: string | undefined;
    tagIds?: string[] | undefined;
    createdAt?: Date;
    updatedAt?: Date;
}

export enum PlatformKind {
    Server = "Server",
    Cluster = "Cluster",
    Serverless = "Serverless",
    ContainerHost = "ContainerHost",
}

export enum Privilege {
    Select = "Select",
    Insert = "Insert",
    Update = "Update",
    Delete = "Delete",
    Execute = "Execute",
    Connect = "Connect",
    Alter = "Alter",
    Control = "Control",
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export class ResolveDriftResponse implements IResolveDriftResponse {
    accountId?: string;
    principalName?: string | undefined;
    success?: boolean;
    operations?: DriftResolutionOperation[] | undefined;
    updatedStatus?: SqlAccountPermissionsStatus;
    errorMessage?: string | undefined;

    constructor(data?: IResolveDriftResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountId = _data["AccountId"];
            this.principalName = _data["PrincipalName"];
            this.success = _data["Success"];
            if (Array.isArray(_data["Operations"])) {
                this.operations = [] as any;
                for (let item of _data["Operations"])
                    this.operations!.push(DriftResolutionOperation.fromJS(item));
            }
            this.updatedStatus = _data["UpdatedStatus"] ? SqlAccountPermissionsStatus.fromJS(_data["UpdatedStatus"]) : undefined as any;
            this.errorMessage = _data["ErrorMessage"];
        }
    }

    static fromJS(data: any): ResolveDriftResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResolveDriftResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AccountId"] = this.accountId;
        data["PrincipalName"] = this.principalName;
        data["Success"] = this.success;
        if (Array.isArray(this.operations)) {
            data["Operations"] = [];
            for (let item of this.operations)
                data["Operations"].push(item ? item.toJSON() : undefined as any);
        }
        data["UpdatedStatus"] = this.updatedStatus ? this.updatedStatus.toJSON() : undefined as any;
        data["ErrorMessage"] = this.errorMessage;
        return data;
    }
}

export interface IResolveDriftResponse {
    accountId?: string;
    principalName?: string | undefined;
    success?: boolean;
    operations?: DriftResolutionOperation[] | undefined;
    updatedStatus?: SqlAccountPermissionsStatus;
    errorMessage?: string | undefined;
}

export class RotateSecret implements IRotateSecret {
    providerId?: string;
    secretName?: string | undefined;
    newSecretValue?: string | undefined;

    constructor(data?: IRotateSecret) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.providerId = _data["ProviderId"];
            this.secretName = _data["SecretName"];
            this.newSecretValue = _data["NewSecretValue"];
        }
    }

    static fromJS(data: any): RotateSecret {
        data = typeof data === 'object' ? data : {};
        let result = new RotateSecret();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ProviderId"] = this.providerId;
        data["SecretName"] = this.secretName;
        data["NewSecretValue"] = this.newSecretValue;
        return data;
    }
}

export interface IRotateSecret {
    providerId?: string;
    secretName?: string | undefined;
    newSecretValue?: string | undefined;
}

export class SecretBinding implements ISecretBinding {
    kind?: SecretBindingKind;
    plainReference?: string | undefined;
    azureKeyVault?: AzureKeyVaultBinding;

    constructor(data?: ISecretBinding) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.kind = _data["Kind"];
            this.plainReference = _data["PlainReference"];
            this.azureKeyVault = _data["AzureKeyVault"] ? AzureKeyVaultBinding.fromJS(_data["AzureKeyVault"]) : undefined as any;
        }
    }

    static fromJS(data: any): SecretBinding {
        data = typeof data === 'object' ? data : {};
        let result = new SecretBinding();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Kind"] = this.kind;
        data["PlainReference"] = this.plainReference;
        data["AzureKeyVault"] = this.azureKeyVault ? this.azureKeyVault.toJSON() : undefined as any;
        return data;
    }
}

export interface ISecretBinding {
    kind?: SecretBindingKind;
    plainReference?: string | undefined;
    azureKeyVault?: AzureKeyVaultBinding;
}

export enum SecretBindingKind {
    None = "None",
    PlainReference = "PlainReference",
    AzureKeyVault = "AzureKeyVault",
}

export class SecretMetadataResponse implements ISecretMetadataResponse {
    name?: string | undefined;
    enabled?: boolean;
    updatedOn?: Date | undefined;
    contentType?: string | undefined;

    constructor(data?: ISecretMetadataResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["Name"];
            this.enabled = _data["Enabled"];
            this.updatedOn = _data["UpdatedOn"] ? new Date(_data["UpdatedOn"].toString()) : undefined as any;
            this.contentType = _data["ContentType"];
        }
    }

    static fromJS(data: any): SecretMetadataResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SecretMetadataResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["Enabled"] = this.enabled;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : undefined as any;
        data["ContentType"] = this.contentType;
        return data;
    }
}

export interface ISecretMetadataResponse {
    name?: string | undefined;
    enabled?: boolean;
    updatedOn?: Date | undefined;
    contentType?: string | undefined;
}

export enum SecretProviderAuthMode {
    ManagedIdentity = "ManagedIdentity",
    ClientSecret = "ClientSecret",
}

export enum SecretProviderCapabilities {
    None = "None",
    Check = "Check",
    Create = "Create",
    Rotate = "Rotate",
    Read = "Read",
}

export class SecretProviderCredentials implements ISecretProviderCredentials {
    tenantId?: string | undefined;
    clientId?: string | undefined;
    clientSecret?: string | undefined;

    constructor(data?: ISecretProviderCredentials) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["TenantId"];
            this.clientId = _data["ClientId"];
            this.clientSecret = _data["ClientSecret"];
        }
    }

    static fromJS(data: any): SecretProviderCredentials {
        data = typeof data === 'object' ? data : {};
        let result = new SecretProviderCredentials();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TenantId"] = this.tenantId;
        data["ClientId"] = this.clientId;
        data["ClientSecret"] = this.clientSecret;
        return data;
    }
}

export interface ISecretProviderCredentials {
    tenantId?: string | undefined;
    clientId?: string | undefined;
    clientSecret?: string | undefined;
}

export class SecretProviderResponse implements ISecretProviderResponse {
    id?: string;
    name?: string | undefined;
    vaultUri?: string | undefined;
    authMode?: SecretProviderAuthMode;
    capabilities?: SecretProviderCapabilities;
    createdAt?: Date;
    updatedAt?: Date;

    constructor(data?: ISecretProviderResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.vaultUri = _data["VaultUri"];
            this.authMode = _data["AuthMode"];
            this.capabilities = _data["Capabilities"];
            this.createdAt = _data["CreatedAt"] ? new Date(_data["CreatedAt"].toString()) : undefined as any;
            this.updatedAt = _data["UpdatedAt"] ? new Date(_data["UpdatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): SecretProviderResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SecretProviderResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["VaultUri"] = this.vaultUri;
        data["AuthMode"] = this.authMode;
        data["Capabilities"] = this.capabilities;
        data["CreatedAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        return data;
    }
}

export interface ISecretProviderResponse {
    id?: string;
    name?: string | undefined;
    vaultUri?: string | undefined;
    authMode?: SecretProviderAuthMode;
    capabilities?: SecretProviderCapabilities;
    createdAt?: Date;
    updatedAt?: Date;
}

export class SecretValueResponse implements ISecretValueResponse {
    value?: string | undefined;

    constructor(data?: ISecretValueResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["Value"];
        }
    }

    static fromJS(data: any): SecretValueResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SecretValueResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Value"] = this.value;
        return data;
    }
}

export interface ISecretValueResponse {
    value?: string | undefined;
}

export enum SecurityLevel {
    None = "None",
    RestrictedEditing = "RestrictedEditing",
    FullyRestricted = "FullyRestricted",
}

export enum SecurityRole {
    Reader = "Reader",
    Admin = "Admin",
}

export class SecuritySettings implements ISecuritySettings {
    level?: SecurityLevel;
    updatedAt?: Date;

    constructor(data?: ISecuritySettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.level = _data["Level"];
            this.updatedAt = _data["UpdatedAt"] ? new Date(_data["UpdatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): SecuritySettings {
        data = typeof data === 'object' ? data : {};
        let result = new SecuritySettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Level"] = this.level;
        data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        return data;
    }
}

export interface ISecuritySettings {
    level?: SecurityLevel;
    updatedAt?: Date;
}

export class SecurityStateResponse implements ISecurityStateResponse {
    level?: SecurityLevel;
    updatedAt?: Date;
    requiresSetup?: boolean;
    hasUsers?: boolean;
    currentUser?: SecurityUserInfo;

    constructor(data?: ISecurityStateResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.level = _data["Level"];
            this.updatedAt = _data["UpdatedAt"] ? new Date(_data["UpdatedAt"].toString()) : undefined as any;
            this.requiresSetup = _data["RequiresSetup"];
            this.hasUsers = _data["HasUsers"];
            this.currentUser = _data["CurrentUser"] ? SecurityUserInfo.fromJS(_data["CurrentUser"]) : undefined as any;
        }
    }

    static fromJS(data: any): SecurityStateResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SecurityStateResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Level"] = this.level;
        data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        data["RequiresSetup"] = this.requiresSetup;
        data["HasUsers"] = this.hasUsers;
        data["CurrentUser"] = this.currentUser ? this.currentUser.toJSON() : undefined as any;
        return data;
    }
}

export interface ISecurityStateResponse {
    level?: SecurityLevel;
    updatedAt?: Date;
    requiresSetup?: boolean;
    hasUsers?: boolean;
    currentUser?: SecurityUserInfo;
}

export class SecurityUserInfo implements ISecurityUserInfo {
    id?: string;
    userName?: string | undefined;
    role?: SecurityRole;
    createdAt?: Date;
    updatedAt?: Date;

    constructor(data?: ISecurityUserInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.userName = _data["UserName"];
            this.role = _data["Role"];
            this.createdAt = _data["CreatedAt"] ? new Date(_data["CreatedAt"].toString()) : undefined as any;
            this.updatedAt = _data["UpdatedAt"] ? new Date(_data["UpdatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): SecurityUserInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SecurityUserInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["UserName"] = this.userName;
        data["Role"] = this.role;
        data["CreatedAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        return data;
    }
}

export interface ISecurityUserInfo {
    id?: string;
    userName?: string | undefined;
    role?: SecurityRole;
    createdAt?: Date;
    updatedAt?: Date;
}

export class SecurityUserResponse implements ISecurityUserResponse {
    id?: string;
    userName?: string | undefined;
    role?: SecurityRole;
    createdAt?: Date;
    updatedAt?: Date;

    constructor(data?: ISecurityUserResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.userName = _data["UserName"];
            this.role = _data["Role"];
            this.createdAt = _data["CreatedAt"] ? new Date(_data["CreatedAt"].toString()) : undefined as any;
            this.updatedAt = _data["UpdatedAt"] ? new Date(_data["UpdatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): SecurityUserResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SecurityUserResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["UserName"] = this.userName;
        data["Role"] = this.role;
        data["CreatedAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        return data;
    }
}

export interface ISecurityUserResponse {
    id?: string;
    userName?: string | undefined;
    role?: SecurityRole;
    createdAt?: Date;
    updatedAt?: Date;
}

export class SqlAccountCreationOperation implements ISqlAccountCreationOperation {
    operationType?: string | undefined;
    database?: string | undefined;
    success?: boolean;
    errorMessage?: string | undefined;

    constructor(data?: ISqlAccountCreationOperation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.operationType = _data["OperationType"];
            this.database = _data["Database"];
            this.success = _data["Success"];
            this.errorMessage = _data["ErrorMessage"];
        }
    }

    static fromJS(data: any): SqlAccountCreationOperation {
        data = typeof data === 'object' ? data : {};
        let result = new SqlAccountCreationOperation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["OperationType"] = this.operationType;
        data["Database"] = this.database;
        data["Success"] = this.success;
        data["ErrorMessage"] = this.errorMessage;
        return data;
    }
}

export interface ISqlAccountCreationOperation {
    operationType?: string | undefined;
    database?: string | undefined;
    success?: boolean;
    errorMessage?: string | undefined;
}

export class SqlAccountPermissionsStatus implements ISqlAccountPermissionsStatus {
    accountId?: string;
    accountName?: string | undefined;
    principalName?: string | undefined;
    status?: SyncStatus;
    permissionComparisons?: SqlPermissionComparison[] | undefined;
    errorMessage?: string | undefined;

    constructor(data?: ISqlAccountPermissionsStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountId = _data["AccountId"];
            this.accountName = _data["AccountName"];
            this.principalName = _data["PrincipalName"];
            this.status = _data["Status"];
            if (Array.isArray(_data["PermissionComparisons"])) {
                this.permissionComparisons = [] as any;
                for (let item of _data["PermissionComparisons"])
                    this.permissionComparisons!.push(SqlPermissionComparison.fromJS(item));
            }
            this.errorMessage = _data["ErrorMessage"];
        }
    }

    static fromJS(data: any): SqlAccountPermissionsStatus {
        data = typeof data === 'object' ? data : {};
        let result = new SqlAccountPermissionsStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AccountId"] = this.accountId;
        data["AccountName"] = this.accountName;
        data["PrincipalName"] = this.principalName;
        data["Status"] = this.status;
        if (Array.isArray(this.permissionComparisons)) {
            data["PermissionComparisons"] = [];
            for (let item of this.permissionComparisons)
                data["PermissionComparisons"].push(item ? item.toJSON() : undefined as any);
        }
        data["ErrorMessage"] = this.errorMessage;
        return data;
    }
}

export interface ISqlAccountPermissionsStatus {
    accountId?: string;
    accountName?: string | undefined;
    principalName?: string | undefined;
    status?: SyncStatus;
    permissionComparisons?: SqlPermissionComparison[] | undefined;
    errorMessage?: string | undefined;
}

export class SqlActualGrant implements ISqlActualGrant {
    database?: string | undefined;
    schema?: string | undefined;
    privileges?: Privilege[] | undefined;

    constructor(data?: ISqlActualGrant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.database = _data["Database"];
            this.schema = _data["Schema"];
            if (Array.isArray(_data["Privileges"])) {
                this.privileges = [] as any;
                for (let item of _data["Privileges"])
                    this.privileges!.push(item);
            }
        }
    }

    static fromJS(data: any): SqlActualGrant {
        data = typeof data === 'object' ? data : {};
        let result = new SqlActualGrant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Database"] = this.database;
        data["Schema"] = this.schema;
        if (Array.isArray(this.privileges)) {
            data["Privileges"] = [];
            for (let item of this.privileges)
                data["Privileges"].push(item);
        }
        return data;
    }
}

export interface ISqlActualGrant {
    database?: string | undefined;
    schema?: string | undefined;
    privileges?: Privilege[] | undefined;
}

export class SqlConnectionTestResult implements ISqlConnectionTestResult {
    isSuccessful?: boolean;
    permissions?: SqlPermissions;
    errorMessage?: string | undefined;

    constructor(data?: ISqlConnectionTestResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccessful = _data["IsSuccessful"];
            this.permissions = _data["Permissions"];
            this.errorMessage = _data["ErrorMessage"];
        }
    }

    static fromJS(data: any): SqlConnectionTestResult {
        data = typeof data === 'object' ? data : {};
        let result = new SqlConnectionTestResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["IsSuccessful"] = this.isSuccessful;
        data["Permissions"] = this.permissions;
        data["ErrorMessage"] = this.errorMessage;
        return data;
    }
}

export interface ISqlConnectionTestResult {
    isSuccessful?: boolean;
    permissions?: SqlPermissions;
    errorMessage?: string | undefined;
}

export class SqlDatabasesResponse implements ISqlDatabasesResponse {
    databases?: string[] | undefined;

    constructor(data?: ISqlDatabasesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["Databases"])) {
                this.databases = [] as any;
                for (let item of _data["Databases"])
                    this.databases!.push(item);
            }
        }
    }

    static fromJS(data: any): SqlDatabasesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SqlDatabasesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.databases)) {
            data["Databases"] = [];
            for (let item of this.databases)
                data["Databases"].push(item);
        }
        return data;
    }
}

export interface ISqlDatabasesResponse {
    databases?: string[] | undefined;
}

export class SqlIntegrationPermissionsOverviewResponse implements ISqlIntegrationPermissionsOverviewResponse {
    integrationId?: string;
    integrationName?: string | undefined;
    accounts?: SqlAccountPermissionsStatus[] | undefined;
    orphanPrincipals?: SqlOrphanPrincipal[] | undefined;
    summary?: SqlPermissionsOverviewSummary;
    errorMessage?: string | undefined;

    constructor(data?: ISqlIntegrationPermissionsOverviewResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.integrationId = _data["IntegrationId"];
            this.integrationName = _data["IntegrationName"];
            if (Array.isArray(_data["Accounts"])) {
                this.accounts = [] as any;
                for (let item of _data["Accounts"])
                    this.accounts!.push(SqlAccountPermissionsStatus.fromJS(item));
            }
            if (Array.isArray(_data["OrphanPrincipals"])) {
                this.orphanPrincipals = [] as any;
                for (let item of _data["OrphanPrincipals"])
                    this.orphanPrincipals!.push(SqlOrphanPrincipal.fromJS(item));
            }
            this.summary = _data["Summary"] ? SqlPermissionsOverviewSummary.fromJS(_data["Summary"]) : undefined as any;
            this.errorMessage = _data["ErrorMessage"];
        }
    }

    static fromJS(data: any): SqlIntegrationPermissionsOverviewResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SqlIntegrationPermissionsOverviewResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["IntegrationId"] = this.integrationId;
        data["IntegrationName"] = this.integrationName;
        if (Array.isArray(this.accounts)) {
            data["Accounts"] = [];
            for (let item of this.accounts)
                data["Accounts"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.orphanPrincipals)) {
            data["OrphanPrincipals"] = [];
            for (let item of this.orphanPrincipals)
                data["OrphanPrincipals"].push(item ? item.toJSON() : undefined as any);
        }
        data["Summary"] = this.summary ? this.summary.toJSON() : undefined as any;
        data["ErrorMessage"] = this.errorMessage;
        return data;
    }
}

export interface ISqlIntegrationPermissionsOverviewResponse {
    integrationId?: string;
    integrationName?: string | undefined;
    accounts?: SqlAccountPermissionsStatus[] | undefined;
    orphanPrincipals?: SqlOrphanPrincipal[] | undefined;
    summary?: SqlPermissionsOverviewSummary;
    errorMessage?: string | undefined;
}

export class SqlIntegrationResponse implements ISqlIntegrationResponse {
    id?: string;
    name?: string | undefined;
    dataStoreId?: string;
    permissions?: SqlPermissions;
    createdAt?: Date;
    updatedAt?: Date;

    constructor(data?: ISqlIntegrationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.dataStoreId = _data["DataStoreId"];
            this.permissions = _data["Permissions"];
            this.createdAt = _data["CreatedAt"] ? new Date(_data["CreatedAt"].toString()) : undefined as any;
            this.updatedAt = _data["UpdatedAt"] ? new Date(_data["UpdatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): SqlIntegrationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SqlIntegrationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["DataStoreId"] = this.dataStoreId;
        data["Permissions"] = this.permissions;
        data["CreatedAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        return data;
    }
}

export interface ISqlIntegrationResponse {
    id?: string;
    name?: string | undefined;
    dataStoreId?: string;
    permissions?: SqlPermissions;
    createdAt?: Date;
    updatedAt?: Date;
}

export class SqlOrphanPrincipal implements ISqlOrphanPrincipal {
    principalName?: string | undefined;
    actualPermissions?: SqlActualGrant[] | undefined;

    constructor(data?: ISqlOrphanPrincipal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.principalName = _data["PrincipalName"];
            if (Array.isArray(_data["ActualPermissions"])) {
                this.actualPermissions = [] as any;
                for (let item of _data["ActualPermissions"])
                    this.actualPermissions!.push(SqlActualGrant.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SqlOrphanPrincipal {
        data = typeof data === 'object' ? data : {};
        let result = new SqlOrphanPrincipal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PrincipalName"] = this.principalName;
        if (Array.isArray(this.actualPermissions)) {
            data["ActualPermissions"] = [];
            for (let item of this.actualPermissions)
                data["ActualPermissions"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface ISqlOrphanPrincipal {
    principalName?: string | undefined;
    actualPermissions?: SqlActualGrant[] | undefined;
}

export class SqlPermissionComparison implements ISqlPermissionComparison {
    database?: string | undefined;
    schema?: string | undefined;
    configuredPrivileges?: Privilege[] | undefined;
    actualPrivileges?: Privilege[] | undefined;
    missingPrivileges?: Privilege[] | undefined;
    extraPrivileges?: Privilege[] | undefined;

    constructor(data?: ISqlPermissionComparison) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.database = _data["Database"];
            this.schema = _data["Schema"];
            if (Array.isArray(_data["ConfiguredPrivileges"])) {
                this.configuredPrivileges = [] as any;
                for (let item of _data["ConfiguredPrivileges"])
                    this.configuredPrivileges!.push(item);
            }
            if (Array.isArray(_data["ActualPrivileges"])) {
                this.actualPrivileges = [] as any;
                for (let item of _data["ActualPrivileges"])
                    this.actualPrivileges!.push(item);
            }
            if (Array.isArray(_data["MissingPrivileges"])) {
                this.missingPrivileges = [] as any;
                for (let item of _data["MissingPrivileges"])
                    this.missingPrivileges!.push(item);
            }
            if (Array.isArray(_data["ExtraPrivileges"])) {
                this.extraPrivileges = [] as any;
                for (let item of _data["ExtraPrivileges"])
                    this.extraPrivileges!.push(item);
            }
        }
    }

    static fromJS(data: any): SqlPermissionComparison {
        data = typeof data === 'object' ? data : {};
        let result = new SqlPermissionComparison();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Database"] = this.database;
        data["Schema"] = this.schema;
        if (Array.isArray(this.configuredPrivileges)) {
            data["ConfiguredPrivileges"] = [];
            for (let item of this.configuredPrivileges)
                data["ConfiguredPrivileges"].push(item);
        }
        if (Array.isArray(this.actualPrivileges)) {
            data["ActualPrivileges"] = [];
            for (let item of this.actualPrivileges)
                data["ActualPrivileges"].push(item);
        }
        if (Array.isArray(this.missingPrivileges)) {
            data["MissingPrivileges"] = [];
            for (let item of this.missingPrivileges)
                data["MissingPrivileges"].push(item);
        }
        if (Array.isArray(this.extraPrivileges)) {
            data["ExtraPrivileges"] = [];
            for (let item of this.extraPrivileges)
                data["ExtraPrivileges"].push(item);
        }
        return data;
    }
}

export interface ISqlPermissionComparison {
    database?: string | undefined;
    schema?: string | undefined;
    configuredPrivileges?: Privilege[] | undefined;
    actualPrivileges?: Privilege[] | undefined;
    missingPrivileges?: Privilege[] | undefined;
    extraPrivileges?: Privilege[] | undefined;
}

export enum SqlPermissions {
    None = "None",
    Read = "Read",
    Write = "Write",
    Create = "Create",
}

export class SqlPermissionsOverviewSummary implements ISqlPermissionsOverviewSummary {
    totalAccounts?: number;
    inSyncCount?: number;
    driftCount?: number;
    missingPrincipalCount?: number;
    errorCount?: number;
    orphanPrincipalCount?: number;

    constructor(data?: ISqlPermissionsOverviewSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalAccounts = _data["TotalAccounts"];
            this.inSyncCount = _data["InSyncCount"];
            this.driftCount = _data["DriftCount"];
            this.missingPrincipalCount = _data["MissingPrincipalCount"];
            this.errorCount = _data["ErrorCount"];
            this.orphanPrincipalCount = _data["OrphanPrincipalCount"];
        }
    }

    static fromJS(data: any): SqlPermissionsOverviewSummary {
        data = typeof data === 'object' ? data : {};
        let result = new SqlPermissionsOverviewSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TotalAccounts"] = this.totalAccounts;
        data["InSyncCount"] = this.inSyncCount;
        data["DriftCount"] = this.driftCount;
        data["MissingPrincipalCount"] = this.missingPrincipalCount;
        data["ErrorCount"] = this.errorCount;
        data["OrphanPrincipalCount"] = this.orphanPrincipalCount;
        return data;
    }
}

export interface ISqlPermissionsOverviewSummary {
    totalAccounts?: number;
    inSyncCount?: number;
    driftCount?: number;
    missingPrincipalCount?: number;
    errorCount?: number;
    orphanPrincipalCount?: number;
}

export enum SyncStatus {
    InSync = "InSync",
    DriftDetected = "DriftDetected",
    MissingPrincipal = "MissingPrincipal",
    Error = "Error",
    NotApplicable = "NotApplicable",
}

export class Tag implements ITag {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    color?: TagColor;

    constructor(data?: ITag) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.description = _data["Description"];
            this.color = _data["Color"];
        }
    }

    static fromJS(data: any): Tag {
        data = typeof data === 'object' ? data : {};
        let result = new Tag();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Description"] = this.description;
        data["Color"] = this.color;
        return data;
    }
}

export interface ITag {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    color?: TagColor;
}

export enum TagColor {
    Red = "Red",
    Green = "Green",
    Blue = "Blue",
    Yellow = "Yellow",
    Purple = "Purple",
    Orange = "Orange",
    Teal = "Teal",
    Gray = "Gray",
}

export enum TargetKind {
    Application = "Application",
    DataStore = "DataStore",
    External = "External",
}

export class TestSecretProviderConnection implements ITestSecretProviderConnection {
    vaultUri?: string | undefined;
    authMode?: SecretProviderAuthMode;
    credentials?: SecretProviderCredentials;

    constructor(data?: ITestSecretProviderConnection) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vaultUri = _data["VaultUri"];
            this.authMode = _data["AuthMode"];
            this.credentials = _data["Credentials"] ? SecretProviderCredentials.fromJS(_data["Credentials"]) : undefined as any;
        }
    }

    static fromJS(data: any): TestSecretProviderConnection {
        data = typeof data === 'object' ? data : {};
        let result = new TestSecretProviderConnection();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["VaultUri"] = this.vaultUri;
        data["AuthMode"] = this.authMode;
        data["Credentials"] = this.credentials ? this.credentials.toJSON() : undefined as any;
        return data;
    }
}

export interface ITestSecretProviderConnection {
    vaultUri?: string | undefined;
    authMode?: SecretProviderAuthMode;
    credentials?: SecretProviderCredentials;
}

export class TestSqlConnection implements ITestSqlConnection {
    connectionString?: string | undefined;

    constructor(data?: ITestSqlConnection) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.connectionString = _data["ConnectionString"];
        }
    }

    static fromJS(data: any): TestSqlConnection {
        data = typeof data === 'object' ? data : {};
        let result = new TestSqlConnection();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ConnectionString"] = this.connectionString;
        return data;
    }
}

export interface ITestSqlConnection {
    connectionString?: string | undefined;
}

export class UpdateAccount implements IUpdateAccount {
    id?: string;
    targetId?: string;
    targetKind?: TargetKind;
    authKind?: AuthKind;
    secretBinding?: SecretBinding;
    userName?: string | undefined;
    parameters?: { [key: string]: string; } | undefined;
    grants?: Grant[] | undefined;
    tagIds?: string[] | undefined;

    constructor(data?: IUpdateAccount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.targetId = _data["TargetId"];
            this.targetKind = _data["TargetKind"];
            this.authKind = _data["AuthKind"];
            this.secretBinding = _data["SecretBinding"] ? SecretBinding.fromJS(_data["SecretBinding"]) : undefined as any;
            this.userName = _data["UserName"];
            if (_data["Parameters"]) {
                this.parameters = {} as any;
                for (let key in _data["Parameters"]) {
                    if (_data["Parameters"].hasOwnProperty(key))
                        (this.parameters as any)![key] = _data["Parameters"][key];
                }
            }
            if (Array.isArray(_data["Grants"])) {
                this.grants = [] as any;
                for (let item of _data["Grants"])
                    this.grants!.push(Grant.fromJS(item));
            }
            if (Array.isArray(_data["TagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["TagIds"])
                    this.tagIds!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateAccount {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAccount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["TargetId"] = this.targetId;
        data["TargetKind"] = this.targetKind;
        data["AuthKind"] = this.authKind;
        data["SecretBinding"] = this.secretBinding ? this.secretBinding.toJSON() : undefined as any;
        data["UserName"] = this.userName;
        if (this.parameters) {
            data["Parameters"] = {};
            for (let key in this.parameters) {
                if (this.parameters.hasOwnProperty(key))
                    (data["Parameters"] as any)[key] = (this.parameters as any)[key];
            }
        }
        if (Array.isArray(this.grants)) {
            data["Grants"] = [];
            for (let item of this.grants)
                data["Grants"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.tagIds)) {
            data["TagIds"] = [];
            for (let item of this.tagIds)
                data["TagIds"].push(item);
        }
        return data;
    }
}

export interface IUpdateAccount {
    id?: string;
    targetId?: string;
    targetKind?: TargetKind;
    authKind?: AuthKind;
    secretBinding?: SecretBinding;
    userName?: string | undefined;
    parameters?: { [key: string]: string; } | undefined;
    grants?: Grant[] | undefined;
    tagIds?: string[] | undefined;
}

export class UpdateAccountGrant implements IUpdateAccountGrant {
    accountId?: string;
    grantId?: string;
    database?: string | undefined;
    schema?: string | undefined;
    privileges?: Privilege[] | undefined;

    constructor(data?: IUpdateAccountGrant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountId = _data["AccountId"];
            this.grantId = _data["GrantId"];
            this.database = _data["Database"];
            this.schema = _data["Schema"];
            if (Array.isArray(_data["Privileges"])) {
                this.privileges = [] as any;
                for (let item of _data["Privileges"])
                    this.privileges!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateAccountGrant {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAccountGrant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AccountId"] = this.accountId;
        data["GrantId"] = this.grantId;
        data["Database"] = this.database;
        data["Schema"] = this.schema;
        if (Array.isArray(this.privileges)) {
            data["Privileges"] = [];
            for (let item of this.privileges)
                data["Privileges"].push(item);
        }
        return data;
    }
}

export interface IUpdateAccountGrant {
    accountId?: string;
    grantId?: string;
    database?: string | undefined;
    schema?: string | undefined;
    privileges?: Privilege[] | undefined;
}

export class UpdateApplication implements IUpdateApplication {
    id?: string;
    name?: string | undefined;
    version?: string | undefined;
    description?: string | undefined;
    owner?: string | undefined;
    notes?: string | undefined;
    framework?: string | undefined;
    repositoryUri?: string | undefined;
    icon?: string | undefined;
    tagIds?: string[] | undefined;

    constructor(data?: IUpdateApplication) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.version = _data["Version"];
            this.description = _data["Description"];
            this.owner = _data["Owner"];
            this.notes = _data["Notes"];
            this.framework = _data["Framework"];
            this.repositoryUri = _data["RepositoryUri"];
            this.icon = _data["Icon"];
            if (Array.isArray(_data["TagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["TagIds"])
                    this.tagIds!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateApplication {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateApplication();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Version"] = this.version;
        data["Description"] = this.description;
        data["Owner"] = this.owner;
        data["Notes"] = this.notes;
        data["Framework"] = this.framework;
        data["RepositoryUri"] = this.repositoryUri;
        data["Icon"] = this.icon;
        if (Array.isArray(this.tagIds)) {
            data["TagIds"] = [];
            for (let item of this.tagIds)
                data["TagIds"].push(item);
        }
        return data;
    }
}

export interface IUpdateApplication {
    id?: string;
    name?: string | undefined;
    version?: string | undefined;
    description?: string | undefined;
    owner?: string | undefined;
    notes?: string | undefined;
    framework?: string | undefined;
    repositoryUri?: string | undefined;
    icon?: string | undefined;
    tagIds?: string[] | undefined;
}

export class UpdateApplicationDependency implements IUpdateApplicationDependency {
    applicationId?: string;
    instanceId?: string;
    dependencyId?: string;
    targetId?: string;
    targetKind?: TargetKind;
    port?: number | undefined;
    authKind?: DependencyAuthKind;
    accountId?: string | undefined;
    identityId?: string | undefined;

    constructor(data?: IUpdateApplicationDependency) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.applicationId = _data["ApplicationId"];
            this.instanceId = _data["InstanceId"];
            this.dependencyId = _data["DependencyId"];
            this.targetId = _data["TargetId"];
            this.targetKind = _data["TargetKind"];
            this.port = _data["Port"];
            this.authKind = _data["AuthKind"];
            this.accountId = _data["AccountId"];
            this.identityId = _data["IdentityId"];
        }
    }

    static fromJS(data: any): UpdateApplicationDependency {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateApplicationDependency();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ApplicationId"] = this.applicationId;
        data["InstanceId"] = this.instanceId;
        data["DependencyId"] = this.dependencyId;
        data["TargetId"] = this.targetId;
        data["TargetKind"] = this.targetKind;
        data["Port"] = this.port;
        data["AuthKind"] = this.authKind;
        data["AccountId"] = this.accountId;
        data["IdentityId"] = this.identityId;
        return data;
    }
}

export interface IUpdateApplicationDependency {
    applicationId?: string;
    instanceId?: string;
    dependencyId?: string;
    targetId?: string;
    targetKind?: TargetKind;
    port?: number | undefined;
    authKind?: DependencyAuthKind;
    accountId?: string | undefined;
    identityId?: string | undefined;
}

export class UpdateApplicationInstance implements IUpdateApplicationInstance {
    applicationId?: string;
    instanceId?: string;
    environmentId?: string;
    platformId?: string | undefined;
    baseUri?: string | undefined;
    healthUri?: string | undefined;
    openApiUri?: string | undefined;
    version?: string | undefined;
    tagIds?: string[] | undefined;

    constructor(data?: IUpdateApplicationInstance) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.applicationId = _data["ApplicationId"];
            this.instanceId = _data["InstanceId"];
            this.environmentId = _data["EnvironmentId"];
            this.platformId = _data["PlatformId"];
            this.baseUri = _data["BaseUri"];
            this.healthUri = _data["HealthUri"];
            this.openApiUri = _data["OpenApiUri"];
            this.version = _data["Version"];
            if (Array.isArray(_data["TagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["TagIds"])
                    this.tagIds!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateApplicationInstance {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateApplicationInstance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ApplicationId"] = this.applicationId;
        data["InstanceId"] = this.instanceId;
        data["EnvironmentId"] = this.environmentId;
        data["PlatformId"] = this.platformId;
        data["BaseUri"] = this.baseUri;
        data["HealthUri"] = this.healthUri;
        data["OpenApiUri"] = this.openApiUri;
        data["Version"] = this.version;
        if (Array.isArray(this.tagIds)) {
            data["TagIds"] = [];
            for (let item of this.tagIds)
                data["TagIds"].push(item);
        }
        return data;
    }
}

export interface IUpdateApplicationInstance {
    applicationId?: string;
    instanceId?: string;
    environmentId?: string;
    platformId?: string | undefined;
    baseUri?: string | undefined;
    healthUri?: string | undefined;
    openApiUri?: string | undefined;
    version?: string | undefined;
    tagIds?: string[] | undefined;
}

export class UpdateApplicationPipeline implements IUpdateApplicationPipeline {
    applicationId?: string;
    pipelineId?: string;
    name?: string | undefined;
    pipelineUri?: string | undefined;

    constructor(data?: IUpdateApplicationPipeline) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.applicationId = _data["ApplicationId"];
            this.pipelineId = _data["PipelineId"];
            this.name = _data["Name"];
            this.pipelineUri = _data["PipelineUri"];
        }
    }

    static fromJS(data: any): UpdateApplicationPipeline {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateApplicationPipeline();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ApplicationId"] = this.applicationId;
        data["PipelineId"] = this.pipelineId;
        data["Name"] = this.name;
        data["PipelineUri"] = this.pipelineUri;
        return data;
    }
}

export interface IUpdateApplicationPipeline {
    applicationId?: string;
    pipelineId?: string;
    name?: string | undefined;
    pipelineUri?: string | undefined;
}

export class UpdateDataStore implements IUpdateDataStore {
    id?: string;
    name?: string | undefined;
    kind?: string | undefined;
    environmentId?: string;
    platformId?: string | undefined;
    connectionUri?: string | undefined;
    tagIds?: string[] | undefined;

    constructor(data?: IUpdateDataStore) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.kind = _data["Kind"];
            this.environmentId = _data["EnvironmentId"];
            this.platformId = _data["PlatformId"];
            this.connectionUri = _data["ConnectionUri"];
            if (Array.isArray(_data["TagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["TagIds"])
                    this.tagIds!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateDataStore {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDataStore();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Kind"] = this.kind;
        data["EnvironmentId"] = this.environmentId;
        data["PlatformId"] = this.platformId;
        data["ConnectionUri"] = this.connectionUri;
        if (Array.isArray(this.tagIds)) {
            data["TagIds"] = [];
            for (let item of this.tagIds)
                data["TagIds"].push(item);
        }
        return data;
    }
}

export interface IUpdateDataStore {
    id?: string;
    name?: string | undefined;
    kind?: string | undefined;
    environmentId?: string;
    platformId?: string | undefined;
    connectionUri?: string | undefined;
    tagIds?: string[] | undefined;
}

export class UpdateEnvironment implements IUpdateEnvironment {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    tagIds?: string[] | undefined;
    autoCreateInstances?: boolean;
    baseUriTemplate?: string | undefined;
    healthUriTemplate?: string | undefined;
    openApiUriTemplate?: string | undefined;

    constructor(data?: IUpdateEnvironment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.description = _data["Description"];
            if (Array.isArray(_data["TagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["TagIds"])
                    this.tagIds!.push(item);
            }
            this.autoCreateInstances = _data["AutoCreateInstances"];
            this.baseUriTemplate = _data["BaseUriTemplate"];
            this.healthUriTemplate = _data["HealthUriTemplate"];
            this.openApiUriTemplate = _data["OpenApiUriTemplate"];
        }
    }

    static fromJS(data: any): UpdateEnvironment {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEnvironment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Description"] = this.description;
        if (Array.isArray(this.tagIds)) {
            data["TagIds"] = [];
            for (let item of this.tagIds)
                data["TagIds"].push(item);
        }
        data["AutoCreateInstances"] = this.autoCreateInstances;
        data["BaseUriTemplate"] = this.baseUriTemplate;
        data["HealthUriTemplate"] = this.healthUriTemplate;
        data["OpenApiUriTemplate"] = this.openApiUriTemplate;
        return data;
    }
}

export interface IUpdateEnvironment {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    tagIds?: string[] | undefined;
    autoCreateInstances?: boolean;
    baseUriTemplate?: string | undefined;
    healthUriTemplate?: string | undefined;
    openApiUriTemplate?: string | undefined;
}

export class UpdateExternalResource implements IUpdateExternalResource {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    resourceUri?: string | undefined;
    tagIds?: string[] | undefined;

    constructor(data?: IUpdateExternalResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.description = _data["Description"];
            this.resourceUri = _data["ResourceUri"];
            if (Array.isArray(_data["TagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["TagIds"])
                    this.tagIds!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateExternalResource {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateExternalResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Description"] = this.description;
        data["ResourceUri"] = this.resourceUri;
        if (Array.isArray(this.tagIds)) {
            data["TagIds"] = [];
            for (let item of this.tagIds)
                data["TagIds"].push(item);
        }
        return data;
    }
}

export interface IUpdateExternalResource {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    resourceUri?: string | undefined;
    tagIds?: string[] | undefined;
}

export class UpdateIdentity implements IUpdateIdentity {
    id?: string;
    name?: string | undefined;
    kind?: IdentityKind;
    notes?: string | undefined;
    ownerInstanceId?: string | undefined;
    assignments?: IdentityAssignment[] | undefined;
    tagIds?: string[] | undefined;

    constructor(data?: IUpdateIdentity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.kind = _data["Kind"];
            this.notes = _data["Notes"];
            this.ownerInstanceId = _data["OwnerInstanceId"];
            if (Array.isArray(_data["Assignments"])) {
                this.assignments = [] as any;
                for (let item of _data["Assignments"])
                    this.assignments!.push(IdentityAssignment.fromJS(item));
            }
            if (Array.isArray(_data["TagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["TagIds"])
                    this.tagIds!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateIdentity {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateIdentity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Kind"] = this.kind;
        data["Notes"] = this.notes;
        data["OwnerInstanceId"] = this.ownerInstanceId;
        if (Array.isArray(this.assignments)) {
            data["Assignments"] = [];
            for (let item of this.assignments)
                data["Assignments"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.tagIds)) {
            data["TagIds"] = [];
            for (let item of this.tagIds)
                data["TagIds"].push(item);
        }
        return data;
    }
}

export interface IUpdateIdentity {
    id?: string;
    name?: string | undefined;
    kind?: IdentityKind;
    notes?: string | undefined;
    ownerInstanceId?: string | undefined;
    assignments?: IdentityAssignment[] | undefined;
    tagIds?: string[] | undefined;
}

export class UpdateIdentityAssignment implements IUpdateIdentityAssignment {
    identityId?: string;
    assignmentId?: string;
    targetKind?: TargetKind;
    targetId?: string;
    role?: string | undefined;
    notes?: string | undefined;

    constructor(data?: IUpdateIdentityAssignment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.identityId = _data["IdentityId"];
            this.assignmentId = _data["AssignmentId"];
            this.targetKind = _data["TargetKind"];
            this.targetId = _data["TargetId"];
            this.role = _data["Role"];
            this.notes = _data["Notes"];
        }
    }

    static fromJS(data: any): UpdateIdentityAssignment {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateIdentityAssignment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["IdentityId"] = this.identityId;
        data["AssignmentId"] = this.assignmentId;
        data["TargetKind"] = this.targetKind;
        data["TargetId"] = this.targetId;
        data["Role"] = this.role;
        data["Notes"] = this.notes;
        return data;
    }
}

export interface IUpdateIdentityAssignment {
    identityId?: string;
    assignmentId?: string;
    targetKind?: TargetKind;
    targetId?: string;
    role?: string | undefined;
    notes?: string | undefined;
}

export class UpdateKumaIntegration implements IUpdateKumaIntegration {
    id?: string;
    name?: string | undefined;
    environmentIds?: string[] | undefined;
    platformId?: string | undefined;
    accountId?: string | undefined;
    uri?: string | undefined;
    apiKey?: string | undefined;

    constructor(data?: IUpdateKumaIntegration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            if (Array.isArray(_data["EnvironmentIds"])) {
                this.environmentIds = [] as any;
                for (let item of _data["EnvironmentIds"])
                    this.environmentIds!.push(item);
            }
            this.platformId = _data["PlatformId"];
            this.accountId = _data["AccountId"];
            this.uri = _data["Uri"];
            this.apiKey = _data["ApiKey"];
        }
    }

    static fromJS(data: any): UpdateKumaIntegration {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateKumaIntegration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        if (Array.isArray(this.environmentIds)) {
            data["EnvironmentIds"] = [];
            for (let item of this.environmentIds)
                data["EnvironmentIds"].push(item);
        }
        data["PlatformId"] = this.platformId;
        data["AccountId"] = this.accountId;
        data["Uri"] = this.uri;
        data["ApiKey"] = this.apiKey;
        return data;
    }
}

export interface IUpdateKumaIntegration {
    id?: string;
    name?: string | undefined;
    environmentIds?: string[] | undefined;
    platformId?: string | undefined;
    accountId?: string | undefined;
    uri?: string | undefined;
    apiKey?: string | undefined;
}

export class UpdatePlatform implements IUpdatePlatform {
    id?: string;
    displayName?: string | undefined;
    dnsName?: string | undefined;
    os?: string | undefined;
    kind?: PlatformKind;
    ipAddress?: string | undefined;
    notes?: string | undefined;
    tagIds?: string[] | undefined;

    constructor(data?: IUpdatePlatform) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.displayName = _data["DisplayName"];
            this.dnsName = _data["DnsName"];
            this.os = _data["Os"];
            this.kind = _data["Kind"];
            this.ipAddress = _data["IpAddress"];
            this.notes = _data["Notes"];
            if (Array.isArray(_data["TagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["TagIds"])
                    this.tagIds!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdatePlatform {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePlatform();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["DisplayName"] = this.displayName;
        data["DnsName"] = this.dnsName;
        data["Os"] = this.os;
        data["Kind"] = this.kind;
        data["IpAddress"] = this.ipAddress;
        data["Notes"] = this.notes;
        if (Array.isArray(this.tagIds)) {
            data["TagIds"] = [];
            for (let item of this.tagIds)
                data["TagIds"].push(item);
        }
        return data;
    }
}

export interface IUpdatePlatform {
    id?: string;
    displayName?: string | undefined;
    dnsName?: string | undefined;
    os?: string | undefined;
    kind?: PlatformKind;
    ipAddress?: string | undefined;
    notes?: string | undefined;
    tagIds?: string[] | undefined;
}

export class UpdateSecretProvider implements IUpdateSecretProvider {
    id?: string;
    name?: string | undefined;
    vaultUri?: string | undefined;
    authMode?: SecretProviderAuthMode;
    credentials?: SecretProviderCredentials;
    capabilities?: SecretProviderCapabilities;

    constructor(data?: IUpdateSecretProvider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.vaultUri = _data["VaultUri"];
            this.authMode = _data["AuthMode"];
            this.credentials = _data["Credentials"] ? SecretProviderCredentials.fromJS(_data["Credentials"]) : undefined as any;
            this.capabilities = _data["Capabilities"];
        }
    }

    static fromJS(data: any): UpdateSecretProvider {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSecretProvider();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["VaultUri"] = this.vaultUri;
        data["AuthMode"] = this.authMode;
        data["Credentials"] = this.credentials ? this.credentials.toJSON() : undefined as any;
        data["Capabilities"] = this.capabilities;
        return data;
    }
}

export interface IUpdateSecretProvider {
    id?: string;
    name?: string | undefined;
    vaultUri?: string | undefined;
    authMode?: SecretProviderAuthMode;
    credentials?: SecretProviderCredentials;
    capabilities?: SecretProviderCapabilities;
}

export class UpdateSecuritySettings implements IUpdateSecuritySettings {
    level?: SecurityLevel;
    requestedBy?: string | undefined;

    constructor(data?: IUpdateSecuritySettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.level = _data["Level"];
            this.requestedBy = _data["RequestedBy"];
        }
    }

    static fromJS(data: any): UpdateSecuritySettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSecuritySettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Level"] = this.level;
        data["RequestedBy"] = this.requestedBy;
        return data;
    }
}

export interface IUpdateSecuritySettings {
    level?: SecurityLevel;
    requestedBy?: string | undefined;
}

export class UpdateSqlIntegration implements IUpdateSqlIntegration {
    id?: string;
    name?: string | undefined;
    dataStoreId?: string;
    connectionString?: string | undefined;

    constructor(data?: IUpdateSqlIntegration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.dataStoreId = _data["DataStoreId"];
            this.connectionString = _data["ConnectionString"];
        }
    }

    static fromJS(data: any): UpdateSqlIntegration {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSqlIntegration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["DataStoreId"] = this.dataStoreId;
        data["ConnectionString"] = this.connectionString;
        return data;
    }
}

export interface IUpdateSqlIntegration {
    id?: string;
    name?: string | undefined;
    dataStoreId?: string;
    connectionString?: string | undefined;
}

export class UpdateTag implements IUpdateTag {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    color?: TagColor;

    constructor(data?: IUpdateTag) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.description = _data["Description"];
            this.color = _data["Color"];
        }
    }

    static fromJS(data: any): UpdateTag {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTag();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Description"] = this.description;
        data["Color"] = this.color;
        return data;
    }
}

export interface IUpdateTag {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    color?: TagColor;
}

export class UpdateUser implements IUpdateUser {
    id?: string;
    role?: SecurityRole;

    constructor(data?: IUpdateUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.role = _data["Role"];
        }
    }

    static fromJS(data: any): UpdateUser {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Role"] = this.role;
        return data;
    }
}

export interface IUpdateUser {
    id?: string;
    role?: SecurityRole;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}